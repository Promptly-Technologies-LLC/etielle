[
  {
    "objectID": "docs/introduction-to-etl.html",
    "href": "docs/introduction-to-etl.html",
    "title": "Introduction to ETL",
    "section": "",
    "text": "What you’ll learn: What ETL (Extract, Transform, Load) means, why it’s important, how it relates to working with JSON data from APIs, and how etielle’s features support each ETL step.",
    "crumbs": [
      "Introduction to ETL"
    ]
  },
  {
    "objectID": "docs/introduction-to-etl.html#what-is-etl",
    "href": "docs/introduction-to-etl.html#what-is-etl",
    "title": "Introduction to ETL",
    "section": "What is ETL?",
    "text": "What is ETL?\nETL stands for Extract, Transform, Load—the three fundamental steps for moving data from one system to another. Understanding these steps is key to understanding how etielle works:\n\n\n\n\n\n\n\n\nETL Step\nWhat it means\nHow etielle does it\n\n\n\n\nExtract\nNavigate and pull data from a source\nTraversals and Mappings walk through nested JSON\n\n\nTransform\nReshape and format the data\nTransforms, Emissions, and Relationships reshape data in memory\n\n\nLoad\nInsert data into the target system\nDatabase adapters (flush_to_db()) persist to database\n\n\n\nETL is a core concept in data engineering and has been used for decades to move data between systems, especially in business intelligence and data warehousing. etielle brings declarative ETL to Python for JSON-to-relational transformations.",
    "crumbs": [
      "Introduction to ETL"
    ]
  },
  {
    "objectID": "docs/introduction-to-etl.html#etl-in-action-a-simple-example",
    "href": "docs/introduction-to-etl.html#etl-in-action-a-simple-example",
    "title": "Introduction to ETL",
    "section": "ETL in Action: A Simple Example",
    "text": "ETL in Action: A Simple Example\nImagine you’re building an app that tracks GitHub repositories. Here’s how each ETL step works, with etielle’s corresponding concepts:\n\n1. Extract: Navigate the JSON structure\nGoal: Pull a subset of data from GitHub’s API (returns nested JSON with repositories, contributors, commits)\nHow etielle does it: Traversals define how to walk through the JSON:\nfrom etielle.core import TraversalSpec\n\n# Extract repositories\nrepos_traversal = TraversalSpec(\n    path=[\"repositories\"],  # Start at \"repositories\" key\n    mode=\"auto\",  # Iterate through the array\n    emits=[...]  # What to do with each repository\n)\n\n# Extract commits nested inside each repository\ncommits_traversal = TraversalSpec(\n    path=[\"repositories\"],\n    mode=\"auto\",\n    inner_path=[\"commits\"],  # Nested path inside each repo\n    inner_mode=\"auto\",\n    emits=[...]  # What to do with each commit\n)\nKey concept: Traversals tell etielle where to go in the JSON and how to iterate through it. They handle the Extract step.\nLearn more: Traversals\n\n\n2. Transform: Reshape data in memory\nGoal: Extract specific fields, link parent-child records, format values, build table structures\nHow etielle does it: Multiple features work together to transform data:\n\nField-level transforms extract and modify individual values: ```python from etielle.transforms import get, get_from_parent, concat, literal\n# Transform: Extract a field from the current item repo_name = get(“name”)\n# Transform: Get a field from the parent (e.g., for relationship linking) parent_repo_id = get_from_parent(“id”)\n# Transform: Remix values into a new output value (e.g. “123” -&gt; “repo_123”) full_id = concat(literal(“repo_”), get(“id”)) ```\nTable-level transforms (Emissions) define output structure: ```python from etielle.core import TableEmit, Field\n# Transform: Define the output table structure (still in memory) TableEmit( table=“repositories”, # Target table name join_keys=[get(“id”)], # Unique identifier (like a primary key) fields=[ Field(“id”, get(“id”)), Field(“name”, get(“name”)), Field(“url”, get(“url”)) ] ) ```\nRelationship transforms link records together in memory (foreign keys, ORM relationships). ```python from etielle.relationships import ManyToOneSpec\n# Transform: Define a many-to-one relationship relationship = ManyToOneSpec( child_table=“commits”, parent_table=“repositories”, # attribute name on the child instance that references the parent instance attr=“repository”, child_to_parent_key=[ # transform to get the parent’s join_key from the child item’s context get(“repository_id”) ], required=True ) ```\n\nKey concept: Transforms, emissions, and relationships are all done in-memory, before database persistence. Although shown separately above, transforms, emissions, and relationship linking are typically combined into a mapping that runs all at once.\nLearn more: Transforms, Emissions, Relationships\n\n\n3. Load: Persist to database\nGoal: Insert the transformed data into PostgreSQL\nHow etielle does it: Database adapters persist the in-memory data:\nfrom etielle.sqlalchemy_adapter import flush_to_db\n\n# Load: Write data to the database\nflush_to_db(session, mapping_results)\nKey concept: The Load step is optional and happens via database adapters. Without this step, etielle just transforms JSON to in-memory Python objects.\nLearn more: Database upserts\n\nThe full ETL flow with etielle:\n\nExtract (Traversals): “Go to repositories, iterate through each one”\nTransform (Transforms + Emissions + Relationships): “Get the name field, format the id, build table rows in memory, associate child records with parent records by parent id”\nLoad (Database adapters): “Persist the in-memory objects to PostgreSQL” (optional)\n\nWithout etielle, you’d write nested loops, manual field extraction, and explicit inserts. With etielle, you declare the mapping once, and the library handles the rest.",
    "crumbs": [
      "Introduction to ETL"
    ]
  },
  {
    "objectID": "docs/introduction-to-etl.html#the-three-pillars-of-etielle-etl",
    "href": "docs/introduction-to-etl.html#the-three-pillars-of-etielle-etl",
    "title": "Introduction to ETL",
    "section": "The Three Pillars of etielle ETL",
    "text": "The Three Pillars of etielle ETL\nTo summarize, etielle implements ETL through three core feature groups:\n\n1. Extract: Traversals and Mappings\nWhat they do: Navigate nested JSON structures and decide what to iterate over\nKey classes: - TraversalSpec: Defines a path through the JSON - MappingSpec: Container for multiple traversals\nExample:\nTraversalSpec(\n    path=[\"users\"],           # Extract: Start here\n    inner_path=[\"posts\"],     # Extract: Then go here\n    mode=\"auto\",              # Extract: How to iterate\n)\nLearn more: Traversals\n\n\n2. Transform: Transforms, Emissions, and Relationships\nWhat they do: Reshape data in memory from nested JSON to structured tables/objects\nKey features:\nField-level transforms: - get(): Get field from current node - get_from_parent(): Get field from ancestor (for relationships) - concat(), format_id(): Format and combine values - coalesce(): Provide fallback values\nTable-level transforms (Emissions): - TableEmit: Build dict tables in memory - InstanceEmit: Build Pydantic/TypedDict/ORM instances in memory - join_keys: Define unique row identifiers for merging\nRelationship transforms: - RelationshipEmit: Link records together (foreign keys, ORM relationships)\nExample:\n# Field transform\nField(\"user_id\", get_from_parent(\"id\"))  # Link to parent\n\n# Table transform\nTableEmit(\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[Field(\"id\", get(\"id\")), Field(\"name\", get(\"name\"))]\n)\nLearn more: Transforms, Emissions, Relationships\n\n\n3. Load: Database Adapters\nWhat they do: Persist the in-memory transformed data to a database (optional)\nKey features: - flush_to_db(): Persist instances to database via SQLAlchemy/SQLModel - One-shot flushing for performance - Relationship binding before persistence\nExample:\nfrom etielle.sqlalchemy_adapter import flush_to_db\n\n# Load: Persist to database\nflush_to_db(session, mapping_results)\nNote: This step is optional! You can use etielle just for in-memory JSON transformation without database persistence.\nLearn more: Database upserts",
    "crumbs": [
      "Introduction to ETL"
    ]
  },
  {
    "objectID": "docs/introduction-to-etl.html#next-steps",
    "href": "docs/introduction-to-etl.html#next-steps",
    "title": "Introduction to ETL",
    "section": "Next Steps",
    "text": "Next Steps\nNow that you understand ETL and how etielle implements each step, you’re ready to dive deeper:\n\nQuickstart - Jump straight into using etielle with a complete example\nTraversals - Master the Extract step: navigate nested JSON\nTransforms - Master the Transform step: field-level data extraction and reshaping\nEmissions - Master the Transform step: table-level structure definition\nRelationships - Master the Transform step: link records together\nDatabase upserts - Master the Load step: persist to database",
    "crumbs": [
      "Introduction to ETL"
    ]
  },
  {
    "objectID": "docs/emissions.html",
    "href": "docs/emissions.html",
    "title": "Emissions: Building Output Tables",
    "section": "",
    "text": "What you’ll learn: How to emit data to dictionaries, Pydantic models, TypedDicts, or ORM objects, with merge logic for progressive construction.\nETL context: Emissions are table-level transformation—the second part of the Transform step. They define the structure of your output tables.",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#what-is-an-emission",
    "href": "docs/emissions.html#what-is-an-emission",
    "title": "Emissions: Building Output Tables",
    "section": "What is an Emission?",
    "text": "What is an Emission?\nAn emission defines what table rows to create at each position in a traversal. There are two types:\n\nTableEmit: Produces plain dictionaries (simple, quick to set up)\nInstanceEmit: Produces typed instances (Pydantic models, TypedDicts, ORM objects)",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#tableemit-quick-and-simple",
    "href": "docs/emissions.html#tableemit-quick-and-simple",
    "title": "Emissions: Building Output Tables",
    "section": "TableEmit: Quick and Simple",
    "text": "TableEmit: Quick and Simple\nUse TableEmit for prototyping or when you just need dictionaries:\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get\nfrom etielle.executor import run_mapping\nimport json\n\ndata = {\"users\": [{\"id\": \"u1\", \"email\": \"alice@example.com\"}]}\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"users\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",\n            join_keys=[get(\"id\")],\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"email\", get(\"email\"))\n            ]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nprint(json.dumps(list(result[\"users\"].instances.values()), indent=2))\n\n[\n  {\n    \"id\": \"u1\",\n    \"email\": \"alice@example.com\"\n  }\n]\n\n\n\nTableEmit Parameters\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\ntable\nstr\nName of the output table\n\n\njoin_keys\nlist[Transform]\nTransforms that produce the unique row identifier\n\n\nfields\nlist[Field]\nList of Field(name, transform) for each column",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#instanceemit-typed-output",
    "href": "docs/emissions.html#instanceemit-typed-output",
    "title": "Emissions: Building Output Tables",
    "section": "InstanceEmit: Typed Output",
    "text": "InstanceEmit: Typed Output\nUse InstanceEmit when you want:\n\nValidation: Pydantic validates as it builds\nType safety: Your IDE knows the exact type\nORM integration: Create database objects directly\n\n\nfrom etielle.core import MappingSpec, TraversalSpec, field_of\nfrom etielle.transforms import get\nfrom etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder\nfrom etielle.executor import run_mapping\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    email: str\n\ndata = {\"users\": [{\"id\": \"u1\", \"email\": \"alice@example.com\"}]}\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"users\"],\n        mode=\"auto\",\n        emits=[InstanceEmit[User](\n            table=\"users\",\n            join_keys=[get(\"id\")],\n            builder=PydanticBuilder(User),\n            fields=[\n                FieldSpec(selector=field_of(User, lambda u: u.id), transform=get(\"id\")),\n                FieldSpec(selector=field_of(User, lambda u: u.email), transform=get(\"email\")),\n            ]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nuser = list(result[\"users\"].instances.values())[0]\nprint(f\"Type: {type(user).__name__}, email: {user.email}\")\n\nType: User, email: alice@example.com",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#builders",
    "href": "docs/emissions.html#builders",
    "title": "Emissions: Building Output Tables",
    "section": "Builders",
    "text": "Builders\nBuilders control how instances are constructed:\n\nPydanticBuilder\nFor Pydantic models with full validation:\nfrom etielle.instances import PydanticBuilder\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    email: str\n\nbuilder = PydanticBuilder(User)\n\n\nPydanticPartialBuilder\nFor Pydantic models where some fields might be missing:\nfrom etielle.instances import PydanticPartialBuilder\n\nbuilder = PydanticPartialBuilder(User)  # Creates partial models\n\n\nTypedDictBuilder\nFor plain dicts or when you don’t want Pydantic:\nfrom typing import TypedDict\nfrom etielle.instances import TypedDictBuilder\n\nclass UserTD(TypedDict):\n    id: str\n    email: str\n\nbuilder = TypedDictBuilder(lambda d: UserTD(**d))\n\n\nConstructorBuilder\nFor ORM objects (SQLAlchemy, SQLModel) or any class that accepts keyword arguments:\nfrom etielle.instances import ConstructorBuilder\n\n# Works with SQLAlchemy/SQLModel models\nbuilder = ConstructorBuilder(User)  # User(**fields)",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#progressive-construction",
    "href": "docs/emissions.html#progressive-construction",
    "title": "Emissions: Building Output Tables",
    "section": "Progressive Construction",
    "text": "Progressive Construction\nMultiple traversals can contribute to the same instance. Rows with matching join_keys are merged:\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get\nfrom etielle.executor import run_mapping\n\ndata = {\n    \"users\": [{\"id\": \"u1\", \"name\": \"Alice\"}],\n    \"profiles\": [{\"user_id\": \"u1\", \"email\": \"alice@example.com\", \"bio\": \"Developer\"}]\n}\n\nspec = MappingSpec(traversals=[\n    # Traversal 1: Basic user info\n    TraversalSpec(\n        path=[\"users\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",\n            join_keys=[get(\"id\")],\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"name\", get(\"name\"))\n            ]\n        )]\n    ),\n    # Traversal 2: Add profile info to the same user\n    TraversalSpec(\n        path=[\"profiles\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",  # Same table!\n            join_keys=[get(\"user_id\")],  # Matches \"u1\"\n            fields=[\n                Field(\"email\", get(\"email\")),\n                Field(\"bio\", get(\"bio\"))\n            ]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nuser = list(result[\"users\"].instances.values())[0]\nprint(user)  # Has id, name, email, and bio\n\n{'id': 'u1', 'name': 'Alice', 'email': 'alice@example.com', 'bio': 'Developer'}",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#merge-policies",
    "href": "docs/emissions.html#merge-policies",
    "title": "Emissions: Building Output Tables",
    "section": "Merge Policies",
    "text": "Merge Policies\nBy default, if two traversals update the same field, the last write wins. Merge policies change this behavior:\n\n\n\n\n\n\n\n\nPolicy\nBehavior\nUse case\n\n\n\n\nAddPolicy()\nAdds numbers together\nCounters, sums, totals\n\n\nAppendPolicy()\nAppends single items to list\nCollecting tags/flags\n\n\nExtendPolicy()\nExtends list with another list\nMerging lists\n\n\nMinPolicy()\nKeeps minimum value\nEarliest date, lowest score\n\n\nMaxPolicy()\nKeeps maximum value\nLatest date, highest score\n\n\nFirstNonNullPolicy()\nKeeps first non-null value\nFallback defaults\n\n\n\n\nExample: Counting with AddPolicy\n\nfrom etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder, AddPolicy\nfrom etielle.transforms import get, literal\nfrom etielle.core import MappingSpec, TraversalSpec\nfrom etielle.executor import run_mapping\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    login_count: int = 0\n\nemit = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=\"id\", transform=get(\"id\")),\n        FieldSpec(selector=\"login_count\", transform=literal(1)),\n    ],\n    builder=PydanticBuilder(User),\n    policies={\"login_count\": AddPolicy()},  # Sum instead of overwrite\n)\n\nroot = {\"users\": [{\"id\": \"u1\"}]}\nmapping = MappingSpec(traversals=[\n    TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[emit]),\n    TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[emit]),  # Same emit twice!\n])\n\nresult = run_mapping(root, mapping)\nuser = list(result[\"users\"].instances.values())[0]\nprint(f\"login_count: {user.login_count}\")  # 2 (1 + 1)\n\nlogin_count: 2\n\n\n\n\nExample: Collecting Tags with AppendPolicy\n\nfrom etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder, AppendPolicy\nfrom etielle.transforms import get, literal\nfrom etielle.core import MappingSpec, TraversalSpec, field_of\nfrom etielle.executor import run_mapping\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    tags: list[str] = []\n\nemit1 = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=field_of(User, lambda u: u.id), transform=get(\"id\")),\n        FieldSpec(selector=field_of(User, lambda u: u.tags), transform=literal(\"verified\")),\n    ],\n    builder=PydanticBuilder(User),\n    policies={\"tags\": AppendPolicy()},\n)\n\nemit2 = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=field_of(User, lambda u: u.tags), transform=literal(\"premium\")),\n    ],\n    builder=PydanticBuilder(User),\n    policies={\"tags\": AppendPolicy()},\n)\n\nroot = {\"users\": [{\"id\": \"u1\"}]}\nmapping = MappingSpec(traversals=[\n    TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[emit1]),\n    TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[emit2]),\n])\n\nresult = run_mapping(root, mapping)\nuser = list(result[\"users\"].instances.values())[0]\nprint(f\"tags: {user.tags}\")  # [\"verified\", \"premium\"]\n\ntags: ['verified', 'premium']",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#type-safe-field-selectors",
    "href": "docs/emissions.html#type-safe-field-selectors",
    "title": "Emissions: Building Output Tables",
    "section": "Type-Safe Field Selectors",
    "text": "Type-Safe Field Selectors\nUse field_of() for type-checked field references:\nfrom etielle.core import field_of\n\nclass User:\n    id: str\n    email: str\n\n# Type-safe: IDE autocomplete, typos caught at type-check time\nfield_of(User, lambda u: u.email)  # Returns \"email\"\n\n# Typo would be caught by type checker:\n# field_of(User, lambda u: u.emial)  # Error!\nWhen to use field selectors vs strings:\n\n\n\nUse field_of() when…\nUse strings when…\n\n\n\n\nWorking with typed models\nWorking with plain dicts\n\n\nUsing a type checker\nPrototyping quickly\n\n\nWant IDE autocomplete\nField names are dynamic",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#instanceemit-reference",
    "href": "docs/emissions.html#instanceemit-reference",
    "title": "Emissions: Building Output Tables",
    "section": "InstanceEmit Reference",
    "text": "InstanceEmit Reference\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\ntable\nstr\nName of the output table\n\n\njoin_keys\nlist[Transform]\nUnique row identifier\n\n\nfields\nlist[FieldSpec]\nField specifications\n\n\nbuilder\nInstanceBuilder\nHow to construct instances\n\n\npolicies\ndict[str, MergePolicy]\nOptional merge policies by field name\n\n\nstrict_fields\nbool\nValidate field names (default: True)\n\n\nstrict_mode\nstr\n\"collect\" (default) or \"fail_fast\"",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/emissions.html#see-also",
    "href": "docs/emissions.html#see-also",
    "title": "Emissions: Building Output Tables",
    "section": "See also",
    "text": "See also\n\nTransforms - The transforms used in Field and FieldSpec\nDeveloping with etielle - Error reporting and debugging\nRelationships - Linking emitted instances together\nDatabase upserts - Persisting instances to a database",
    "crumbs": [
      "Emissions"
    ]
  },
  {
    "objectID": "docs/relationships.html",
    "href": "docs/relationships.html",
    "title": "Relationship building (no extra DB round trips)",
    "section": "",
    "text": "What you’ll learn: How to build parent-child relationships in memory and flush once, avoiding N+1 database queries.\nPrerequisites: Understanding of InstanceEmit and composite keys.\nBuild relationships in-memory using composite keys, then flush once. This avoids per-row database round trips.\n\nMany-to-one via relationship keys\nHere’s how etielle builds relationships without database round trips:\n\nCompute keys: Walk through your JSON again to compute which child belongs to which parent\nStore in sidecar: Keep these relationships separate from your instances (in a “sidecar” dict)\nBind in memory: Link child objects to parent objects using Python references\nFlush once: Save everything to the database in one operation\n\nThis avoids the typical ORM pattern of “insert parent, get ID, insert child with foreign key” which requires multiple queries.\n\n\nExample structure\nJSON:\n{\n  \"users\": [\n    {\"id\": \"u1\", \"posts\": [\n      {\"id\": \"p1\", \"title\": \"Hello\"},\n      {\"id\": \"p2\", \"title\": \"World\"}\n    ]}\n  ]\n}\n\nIn memory after mapping:\nUser(id=\"u1\")\nPost(id=\"p1\", user=None)  ← We need to link this\nPost(id=\"p2\", user=None)  ← And this\n\nAfter bind_many_to_one:\nUser(id=\"u1\")\nPost(id=\"p1\", user=&lt;User u1&gt;)  ← Now linked!\nPost(id=\"p2\", user=&lt;User u1&gt;)  ← Now linked!\n\n\nComplete example\n\nfrom etielle.relationships import ManyToOneSpec, compute_relationship_keys, bind_many_to_one\nfrom etielle.executor import run_mapping\nfrom etielle.transforms import get, get_from_parent\nfrom etielle.core import MappingSpec, TraversalSpec, field_of\nfrom etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    email: str | None = None\n\nclass Post(BaseModel):\n    id: str\n    title: str\n    user: User | None = None\n\nroot = {\n  \"users\": [\n    {\"id\": \"u1\", \"email\": \"alice@example.com\", \"posts\": [\n      {\"id\": \"p1\", \"title\": \"Hello\"},\n      {\"id\": \"p2\", \"title\": \"World\"}\n    ]},\n    {\"id\": \"u2\", \"email\": \"bob@example.com\", \"posts\": []}\n  ]\n}\n\nusers_emit = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=field_of(User, lambda u: u.id), transform=get(\"id\")),\n        FieldSpec(selector=field_of(User, lambda u: u.email), transform=get(\"email\")),\n    ],\n    builder=PydanticBuilder(User),\n)\n\nposts_emit = InstanceEmit[Post](\n    table=\"posts\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=field_of(Post, lambda p: p.id), transform=get(\"id\")),\n        FieldSpec(selector=field_of(Post, lambda p: p.title), transform=get(\"title\")),\n    ],\n    builder=PydanticBuilder(Post),\n)\n\nmapping = MappingSpec(traversals=[\n    TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[users_emit]),\n    TraversalSpec(path=[\"users\"], mode=\"auto\", inner_path=[\"posts\"], inner_mode=\"auto\", emits=[posts_emit]),\n])\n\n# Using the models, emits, mapping, and root from above\nrelationships = [\n    ManyToOneSpec(\n        child_table=\"posts\",\n        parent_table=\"users\",\n        attr=\"user\",\n        child_to_parent_key=[get_from_parent(\"id\")],\n    )\n]\n\nresults = run_mapping(root, mapping)\nsidecar = compute_relationship_keys(root, mapping.traversals, relationships)\nbind_many_to_one(results, relationships, sidecar)\nprint(sorted([(p.id, p.user.id if p.user else None) for p in results[\"posts\"].instances.values()]))\n\n[('p1', 'u1'), ('p2', 'u1')]\n\n\n\n\nBehavior\n\nParent indices are built from finalized instances per table.\nMissing parents aggregate clear errors (optional raise).\nNo mutation of domain objects during key computation (keys stored in sidecar map).\n\nFor a complete SQLAlchemy integration example with automatic flushing, see Database upserts.\n\n\nSee also\n\nDatabase upserts - Full integration with SQLAlchemy/SQLModel ORM\nEmissions - Creating the instances that relationships link",
    "crumbs": [
      "Relationships"
    ]
  },
  {
    "objectID": "docs/traversals.html",
    "href": "docs/traversals.html",
    "title": "Traversals: Navigating JSON Structure",
    "section": "",
    "text": "What you’ll learn: How to use TraversalSpec to navigate nested JSON structures and control iteration behavior.\nETL context: Traversals are the Extract step—they tell etielle where to find data in your JSON and how to iterate through it.",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#what-is-a-traversal",
    "href": "docs/traversals.html#what-is-a-traversal",
    "title": "Traversals: Navigating JSON Structure",
    "section": "What is a Traversal?",
    "text": "What is a Traversal?\nA traversal defines a path through your JSON structure. Think of it as giving directions: “Start at the ‘users’ key, then loop through each item in that array.”\nfrom etielle.core import TraversalSpec\n\ntraversal = TraversalSpec(\n    path=[\"users\"],  # Navigate to the \"users\" key\n    mode=\"auto\",     # Automatically iterate (list → by index, dict → by key-value)\n    emits=[...],     # What to emit at each position (covered later)\n)",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#path-navigation",
    "href": "docs/traversals.html#path-navigation",
    "title": "Traversals: Navigating JSON Structure",
    "section": "Path Navigation",
    "text": "Path Navigation\nThe path parameter is a list of keys/indices that navigate to your target data:\n\n# Simple path: data[\"users\"]\nTraversalSpec(path=[\"users\"])\n\n# Nested path: data[\"response\"][\"data\"][\"users\"]\nTraversalSpec(path=[\"response\", \"data\", \"users\"])\n\n# With index: data[\"pages\"][0][\"items\"]\nTraversalSpec(path=[\"pages\", 0, \"items\"])",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#iteration-modes",
    "href": "docs/traversals.html#iteration-modes",
    "title": "Traversals: Navigating JSON Structure",
    "section": "Iteration Modes",
    "text": "Iteration Modes\nThe mode parameter controls how etielle iterates over the container at your path:\n\n\n\n\n\n\n\n\nMode\nBehavior\nUse case\n\n\n\n\n\"auto\"\nDetects container type: lists iterate by index, dicts iterate by key-value pairs\nDefault, works for most cases\n\n\n\"items\"\nIterates dict key-value pairs (like dict.items())\nWhen you need both key and value from a dict\n\n\n\"single\"\nNo iteration—treats the container as a single node\nWhen you want the whole object, not its children\n\n\n\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get, key\nfrom etielle.executor import run_mapping\nimport json\n\n# Example: Iterating a dict by key-value pairs\ndata = {\n    \"settings\": {\n        \"theme\": \"dark\",\n        \"language\": \"en\",\n        \"notifications\": \"enabled\"\n    }\n}\n\ntraversal = TraversalSpec(\n    path=[\"settings\"],\n    mode=\"items\",  # Iterate key-value pairs\n    emits=[\n        TableEmit(\n            table=\"settings\",\n            join_keys=[key()],  # Use the dict key as identifier\n            fields=[\n                Field(\"name\", key()),      # \"theme\", \"language\", etc.\n                Field(\"value\", get([])),   # \"dark\", \"en\", etc. (empty path = current node)\n            ]\n        )\n    ]\n)\n\nresult = run_mapping(data, MappingSpec(traversals=[traversal]))\nprint(json.dumps(list(result[\"settings\"].instances.values()), indent=2))\n\n[\n  {\n    \"name\": \"theme\",\n    \"value\": \"dark\",\n    \"id\": \"theme\"\n  },\n  {\n    \"name\": \"language\",\n    \"value\": \"en\",\n    \"id\": \"language\"\n  },\n  {\n    \"name\": \"notifications\",\n    \"value\": \"enabled\",\n    \"id\": \"notifications\"\n  }\n]",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#nested-traversals-with-inner_path",
    "href": "docs/traversals.html#nested-traversals-with-inner_path",
    "title": "Traversals: Navigating JSON Structure",
    "section": "Nested Traversals with inner_path",
    "text": "Nested Traversals with inner_path\nFor parent-child relationships (users → posts, orders → items), use inner_path:\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get, get_from_parent\nfrom etielle.executor import run_mapping\nimport json\n\ndata = {\n    \"users\": [\n        {\"id\": \"u1\", \"name\": \"Alice\", \"posts\": [\n            {\"id\": \"p1\", \"title\": \"Hello\"},\n            {\"id\": \"p2\", \"title\": \"World\"}\n        ]},\n        {\"id\": \"u2\", \"name\": \"Bob\", \"posts\": []}\n    ]\n}\n\n# Outer traversal: iterate users\n# Inner traversal: for each user, iterate their posts\nposts_traversal = TraversalSpec(\n    path=[\"users\"],          # First, go to users array\n    mode=\"auto\",             # Iterate each user\n    inner_path=[\"posts\"],    # Then, for each user, go to posts\n    inner_mode=\"auto\",       # Iterate each post\n    emits=[\n        TableEmit(\n            table=\"posts\",\n            join_keys=[get(\"id\")],\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"user_id\", get_from_parent(\"id\")),  # Link to parent user\n                Field(\"title\", get(\"title\"))\n            ]\n        )\n    ]\n)\n\nresult = run_mapping(data, MappingSpec(traversals=[posts_traversal]))\nprint(json.dumps(list(result[\"posts\"].instances.values()), indent=2))\n\n[\n  {\n    \"id\": \"p1\",\n    \"user_id\": \"u1\",\n    \"title\": \"Hello\"\n  },\n  {\n    \"id\": \"p2\",\n    \"user_id\": \"u1\",\n    \"title\": \"World\"\n  }\n]",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#deep-nesting-arbitrary-depth",
    "href": "docs/traversals.html#deep-nesting-arbitrary-depth",
    "title": "Traversals: Navigating JSON Structure",
    "section": "Deep Nesting (Arbitrary Depth)",
    "text": "Deep Nesting (Arbitrary Depth)\nUse longer inner_path lists for deeply nested structures. Use the depth parameter in get_from_parent() to access ancestors:\n\n# servers → channels → messages → reactions (3 levels deep)\nTraversalSpec(\n    path=[\"servers\"],\n    mode=\"auto\",\n    inner_path=[\"channels\", \"messages\", \"reactions\"],\n    inner_mode=\"auto\",\n    emits=[\n        TableEmit(\n            table=\"reactions\",\n            join_keys=[\n                get_from_parent(\"id\", depth=3),  # server_id (great-grandparent)\n                get_from_parent(\"id\", depth=2),  # channel_id (grandparent)\n                get_from_parent(\"id\", depth=1),  # message_id (parent)\n                get(\"id\")                         # reaction_id\n            ],\n            fields=[\n                Field(\"server_id\", get_from_parent(\"id\", depth=3)),\n                Field(\"channel_id\", get_from_parent(\"id\", depth=2)),\n                Field(\"message_id\", get_from_parent(\"id\", depth=1)),\n                Field(\"emoji\", get(\"emoji\"))\n            ]\n        )\n    ]\n)",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#multiple-traversals",
    "href": "docs/traversals.html#multiple-traversals",
    "title": "Traversals: Navigating JSON Structure",
    "section": "Multiple Traversals",
    "text": "Multiple Traversals\nA MappingSpec can contain multiple traversals. They run independently:\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get\nfrom etielle.executor import run_mapping\nimport json\n\ndata = {\n    \"users\": [{\"id\": \"u1\", \"name\": \"Alice\"}],\n    \"products\": [{\"id\": \"prod1\", \"name\": \"Widget\"}]\n}\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"users\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",\n            join_keys=[get(\"id\")],\n            fields=[Field(\"id\", get(\"id\")), Field(\"name\", get(\"name\"))]\n        )]\n    ),\n    TraversalSpec(\n        path=[\"products\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"products\",\n            join_keys=[get(\"id\")],\n            fields=[Field(\"id\", get(\"id\")), Field(\"name\", get(\"name\"))]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nprint(\"Users:\", list(result[\"users\"].instances.values()))\nprint(\"Products:\", list(result[\"products\"].instances.values()))\n\nUsers: [{'id': 'u1', 'name': 'Alice'}]\nProducts: [{'id': 'prod1', 'name': 'Widget'}]",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#row-merging-with-join_keys",
    "href": "docs/traversals.html#row-merging-with-join_keys",
    "title": "Traversals: Navigating JSON Structure",
    "section": "Row Merging with join_keys",
    "text": "Row Merging with join_keys\nWhen multiple traversals emit to the same table with matching join_keys, rows are merged:\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get\nfrom etielle.executor import run_mapping\n\ndata = {\n    \"users\": [{\"id\": \"u1\", \"name\": \"Alice\"}],\n    \"profiles\": [{\"user_id\": \"u1\", \"email\": \"alice@example.com\"}]\n}\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"users\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",\n            join_keys=[get(\"id\")],  # Key: u1\n            fields=[Field(\"id\", get(\"id\")), Field(\"name\", get(\"name\"))]\n        )]\n    ),\n    TraversalSpec(\n        path=[\"profiles\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",  # Same table!\n            join_keys=[get(\"user_id\")],  # Key: u1 (matches above)\n            fields=[Field(\"email\", get(\"email\"))]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nuser = list(result[\"users\"].instances.values())[0]\nprint(user)  # {\"id\": \"u1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n\n{'id': 'u1', 'name': 'Alice', 'email': 'alice@example.com'}",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#traversalspec-reference",
    "href": "docs/traversals.html#traversalspec-reference",
    "title": "Traversals: Navigating JSON Structure",
    "section": "TraversalSpec Reference",
    "text": "TraversalSpec Reference\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\npath\nlist[str, int]\nPath segments to navigate to the target container\n\n\nmode\n\"auto\", \"items\", \"single\"\nHow to iterate the outer container (default: \"auto\")\n\n\ninner_path\nlist[str, int]\nOptional nested path for parent-child traversals\n\n\ninner_mode\n\"auto\", \"items\", \"single\"\nHow to iterate the inner container (default: \"auto\")\n\n\nemits\nlist[TableEmit, InstanceEmit]\nWhat to emit at each iteration position",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "docs/traversals.html#see-also",
    "href": "docs/traversals.html#see-also",
    "title": "Traversals: Navigating JSON Structure",
    "section": "See also",
    "text": "See also\n\nTransforms - Extracting values from each traversal position\nEmissions - Defining output structure (TableEmit, InstanceEmit)",
    "crumbs": [
      "Traversals"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "Changelog",
    "section": "",
    "text": "Support &gt;1 spec per child table (57ee01e)\n\n\n\n\n\nLint code (9f4d3c8)\n\n\n\n\n\nAdd comprehensive introduction to ETL documentation (69e8029)\nIntroduction to ETL (90e0fd1)\nRefine ETL concept mapping in introduction (bbdb9a7)\n\n\n\n\n\n\n\n\nRemove lockfile from version control (0229547)\n\n\n\n\n\nNew ConstructorBuilder for ORMs (977b0a0)\n\n\n\n\n\n\n\n\nClarify field selector docs (cb90959)\nCross-linking, user-friendliness (acb8b87)\nImprove clarity of README (dbc75c2)\nMore detailed emission guide (782ab62)\n\n\n\n\n\nConsolidate/enhance adapter documentation (e6df5ed)\n\n\n\n\n\n\n\n\nMake release workflow ff after publish (506d3c8)\n\n\n\n\n\nAdd backticks around code (e251f3f)\nAll documentation code runs (61dbb24)\nDocumentation website (8019c14)\nExample code triggers errors (b12093e)\nFix header text color (69ab9d4)\nPrint mapping result (1ef1164)\n\n\n\n\n\nSimplify iteration API (25e1c17)\n\n\n\n\n\n\n\n\nSqlalchemy adapter (3ac07a1)\n\n\n\n\n\n\n\n\nMutation-based emit (21dbbe6)\n\n\n\n\n\n\n\n\nError reporting (10657ec)\nInstance emission adapter (4c02de0)\n\n\n\n\n\n\n\n\nImplement field selectors API (e099dbe)\n\n\n\n\n\n\n\n\nConfigure pyproject version stamping (49c4e07)\n\n\n\n\n\n\n\n\nMake release dependent on test (b377958)\n\n\n\n\n\n\n\n\nCorrectly use PyPi env for publish job (2dd6cea)\n\n\n\n\n\n\n\n\nRun build in PSR container (6c359c6)\n\n\n\n\n\n\n\n\nRestore build step (4250642)\n\n\n\n\n\n\n\n\nGate artifact upload (5e5bda1)\n\n\n\n\n\n\n\n\nActions-compliant root path (251d553)\nAdd missing semantic release config (f6235d4)\nSemantic release version mismatch (3dbf9a0)\nUse semantic release’s built-in committer (6681c31)"
  },
  {
    "objectID": "CHANGELOG.html#v2.2.1-2025-11-25",
    "href": "CHANGELOG.html#v2.2.1-2025-11-25",
    "title": "Changelog",
    "section": "",
    "text": "Support &gt;1 spec per child table (57ee01e)\n\n\n\n\n\nLint code (9f4d3c8)\n\n\n\n\n\nAdd comprehensive introduction to ETL documentation (69e8029)\nIntroduction to ETL (90e0fd1)\nRefine ETL concept mapping in introduction (bbdb9a7)"
  },
  {
    "objectID": "CHANGELOG.html#v2.2.0-2025-10-23",
    "href": "CHANGELOG.html#v2.2.0-2025-10-23",
    "title": "Changelog",
    "section": "",
    "text": "Remove lockfile from version control (0229547)\n\n\n\n\n\nNew ConstructorBuilder for ORMs (977b0a0)"
  },
  {
    "objectID": "CHANGELOG.html#v2.1.0-2025-10-20",
    "href": "CHANGELOG.html#v2.1.0-2025-10-20",
    "title": "Changelog",
    "section": "",
    "text": "Clarify field selector docs (cb90959)\nCross-linking, user-friendliness (acb8b87)\nImprove clarity of README (dbc75c2)\nMore detailed emission guide (782ab62)\n\n\n\n\n\nConsolidate/enhance adapter documentation (e6df5ed)"
  },
  {
    "objectID": "CHANGELOG.html#v2.0.0-2025-10-19",
    "href": "CHANGELOG.html#v2.0.0-2025-10-19",
    "title": "Changelog",
    "section": "",
    "text": "Make release workflow ff after publish (506d3c8)\n\n\n\n\n\nAdd backticks around code (e251f3f)\nAll documentation code runs (61dbb24)\nDocumentation website (8019c14)\nExample code triggers errors (b12093e)\nFix header text color (69ab9d4)\nPrint mapping result (1ef1164)\n\n\n\n\n\nSimplify iteration API (25e1c17)"
  },
  {
    "objectID": "CHANGELOG.html#v1.4.0-2025-10-15",
    "href": "CHANGELOG.html#v1.4.0-2025-10-15",
    "title": "Changelog",
    "section": "",
    "text": "Sqlalchemy adapter (3ac07a1)"
  },
  {
    "objectID": "CHANGELOG.html#v1.3.0-2025-10-14",
    "href": "CHANGELOG.html#v1.3.0-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Mutation-based emit (21dbbe6)"
  },
  {
    "objectID": "CHANGELOG.html#v1.2.0-2025-10-14",
    "href": "CHANGELOG.html#v1.2.0-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Error reporting (10657ec)\nInstance emission adapter (4c02de0)"
  },
  {
    "objectID": "CHANGELOG.html#v1.1.0-2025-10-14",
    "href": "CHANGELOG.html#v1.1.0-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Implement field selectors API (e099dbe)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.6-2025-10-14",
    "href": "CHANGELOG.html#v1.0.6-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Configure pyproject version stamping (49c4e07)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.5-2025-10-14",
    "href": "CHANGELOG.html#v1.0.5-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Make release dependent on test (b377958)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.4-2025-10-14",
    "href": "CHANGELOG.html#v1.0.4-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Correctly use PyPi env for publish job (2dd6cea)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.3-2025-10-14",
    "href": "CHANGELOG.html#v1.0.3-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Run build in PSR container (6c359c6)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.2-2025-10-14",
    "href": "CHANGELOG.html#v1.0.2-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Restore build step (4250642)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.1-2025-10-14",
    "href": "CHANGELOG.html#v1.0.1-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Gate artifact upload (5e5bda1)"
  },
  {
    "objectID": "CHANGELOG.html#v1.0.0-2025-10-14",
    "href": "CHANGELOG.html#v1.0.0-2025-10-14",
    "title": "Changelog",
    "section": "",
    "text": "Actions-compliant root path (251d553)\nAdd missing semantic release config (f6235d4)\nSemantic release version mismatch (3dbf9a0)\nUse semantic release’s built-in committer (6681c31)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "",
    "text": "etielle is a simple, powerful Python library for reshaping nested JSON data, typically from an API, into relational tables that fit your database schema. Think of etielle as a “JSON extractor” that you program with clear instructions: “Go here in the JSON, pull this data, and put it in that table.” The library’s name is a play on ETL (“Extract, Transform, Load”), which is the technical term for this set of operations.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#why-use-etielle-for-beginners",
    "href": "index.html#why-use-etielle-for-beginners",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Why Use etielle? (For Beginners)",
    "text": "Why Use etielle? (For Beginners)\nJSON data from APIs (Application Program Interfaces — web services that typically return JSON) is often deeply nested and requires complicated parsing. etielle helps by:\n\nTraversing nested structures: Walk through arrays-within-dictionaries-within-arrays to any arbitrary depth.\nPerforming arbitrary transformations: Use the provided functions to perform common operations (like getting the key or index of the current item or its parent), or define your own custom ones.\nBuilding relationships: Link records across your different output tables and emit ORM relationships or foreign keys.\nEmitting to arbitrary formats: Emit data to Pydantic models, TypedDicts, or ORM objects directly instead of plain dicts, with validation and type safety.\nOptionally loading data into a database: Load data into a database using SQLAlchemy or SQLModel with performant one-shot flushing.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#learning-path",
    "href": "index.html#learning-path",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Learning Path",
    "text": "Learning Path\n\nQuickstart: Quick and dirty introduction to etielle and how to use it.\nIntroduction to ETL: The problem etielle is solving: JSON data ETL (Extract, Transform, and Load).\nTraversals: How to tell etielle how to traverse your JSON data.\nTransforms: Getting and altering values from the JSON data and mapping them in a type-safe way to your output tables.\nEmissions: Outputting data to dictionaries, TypedDicts, Pydantic models, or ORM objects, with merge logic to construct single rows from different parts of the input JSON data.\nDatabase upserts: Optionally, creating relationships in memory and flushing data into a database with performant one-shot flushing.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Installation",
    "text": "Installation\nWe recommend using uv for faster installs, but pip works too.\nuv add etielle\n# or\npip install etielle\n\nOptional: Install with ORM adapters\nIf you plan to bind relationships and flush to your database via SQLAlchemy or SQLModel, install with the optional extra for your ORM:\nuv add \"etielle[sqlalchemy]\"\n# or\nuv add \"etielle[sqlmodel]\"",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#quick-start-your-first-mapping",
    "href": "index.html#quick-start-your-first-mapping",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Quick Start: Your First Mapping",
    "text": "Quick Start: Your First Mapping\nLet’s start with a simple example. Suppose you have this JSON:\n\nimport json\n\ndata = {\n  \"users\": [\n    {\"id\": \"u1\", \"name\": \"Alice\", \"posts\": [{\"id\": \"p1\", \"title\": \"Hello\"}, {\"id\": \"p2\", \"title\": \"World\"}]},\n    {\"id\": \"u2\", \"name\": \"Bob\", \"posts\": []}\n  ]\n}\n\nWe want two tables: “users” (id, name) and “posts” (id, user_id, title).\nHere’s the code:\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field  # Core building blocks\nfrom etielle.transforms import get, get_from_parent  # Functions to pull data from JSON\nfrom etielle.executor import run_mapping  # The engine that runs everything\n\n# A TraversalSpec tells etielle how to walk through your JSON. Think of it as\n# giving directions: \"Start at the 'users' key, then loop through each item in that array.\"\n\n# Traverse users array\nusers_traversal = TraversalSpec(\n    path=[\"users\"],  # Path to the array\n    mode=\"auto\",  # Iterate automatically based on container\n    emits=[\n        # The join_keys identify each unique row—like a primary key in a database.\n        # Rows with matching keys will be merged together.\n        TableEmit(\n            table=\"users\",\n            join_keys=[get(\"id\")],  # Unique key for the row\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"name\", get(\"name\"))\n            ]\n        )\n    ]\n)\n\n# This second traversal is nested: first we navigate to each user,\n# then for each user we go into their posts array using inner_path.\nposts_traversal = TraversalSpec(\n    path=[\"users\"],\n    mode=\"auto\",\n    inner_path=[\"posts\"],  # Nested path inside each user\n    inner_mode=\"auto\",\n    emits=[\n        TableEmit(\n            table=\"posts\",\n            join_keys=[get(\"id\")],\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"user_id\", get_from_parent(\"id\")),  # Link to parent user\n                Field(\"title\", get(\"title\"))\n            ]\n        )\n    ]\n)\n\nspec = MappingSpec(traversals=[users_traversal, posts_traversal])\nresult = run_mapping(data, spec)\n\n# result is a dict: {\"users\": MappingResult, \"posts\": MappingResult}\n# Each MappingResult has .instances (a dict keyed by join_keys)\n# Let's convert to simple lists for display:\nout = {table: list(mr.instances.values()) for table, mr in result.items()}\nprint(json.dumps(out, indent=2))\n\n{\n  \"users\": [\n    {\n      \"id\": \"u1\",\n      \"name\": \"Alice\"\n    },\n    {\n      \"id\": \"u2\",\n      \"name\": \"Bob\"\n    }\n  ],\n  \"posts\": [\n    {\n      \"id\": \"p1\",\n      \"user_id\": \"u1\",\n      \"title\": \"Hello\"\n    },\n    {\n      \"id\": \"p2\",\n      \"user_id\": \"u1\",\n      \"title\": \"World\"\n    }\n  ]\n}\n\n\nCongrats! You’ve mapped your first JSON.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#core-concepts-breaking-it-down",
    "href": "index.html#core-concepts-breaking-it-down",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Core Concepts: Breaking It Down",
    "text": "Core Concepts: Breaking It Down\nLet’s explain the building blocks like you’re learning for the first time.\n\n1. Context: Your “Location” in the JSON\nImagine traversing a JSON tree—Context is your GPS:\n\nroot: The entire JSON.\nnode: The current spot (e.g., a user object).\npath: Directions to get here (e.g., (“users”, 0)).\nparent: The previous spot (for looking “up”).\nkey/index: If in a dict/list, the current key or index.\nslots: A notepad for temporary notes.\n\nContexts are created automatically as you traverse and are immutable (unchangeable) for safety.\n\n\n2. Transforms: Smart Data Extractors\nTransforms are like mini-functions that pull values from Context. They’re “lazy”—they don’t run until needed, and they adapt to the current Context.\nExamples:\n\nget(\"name\"): Get “name” from current node → \"Alice\" when node is {\"name\": \"Alice\"}\nget_from_parent(\"id\"): Get “id” from parent context → \"u1\" when processing a post under user u1\nindex(): Current list position → 0 for first item, 1 for second, etc.\nconcat(literal(\"user_\"), get(\"id\")): Combine strings → \"user_u1\"\n\nFull list in the Cheatsheet below.\n\n\n3. TraversalSpec: How to Walk the JSON\nThis says: “Start here, then go deeper if needed, and do this for each item.”\n\npath: Starting path (list of strings, e.g., [“users”]).\nmode: Iteration mode for the outer container: “auto” (default), “items”, or “single”.\ninner_path: Optional deeper path (e.g., [“posts”] for nesting).\ninner_mode: Iteration mode for the inner container: “auto” (default), “items”, or “single”.\nemits: What tables to create from each item.\n\nYou can have multiple Traversals in one MappingSpec—they run independently.\nHere’s a visual representation of how traversals work:\nJSON structure:\nroot\n└── users []                    ← path=[\"users\"]\n    ├── [0] {\"id\": \"u1\", ...}\n    │   └── posts []            ← inner_path=[\"posts\"]\n    │       ├── [0] {\"id\": \"p1\", \"title\": \"Hello\"}\n    │       └── [1] {\"id\": \"p2\", \"title\": \"World\"}\n    └── [1] {\"id\": \"u2\", ...}\n\n\n4. TableEmit and Fields: Building Your Tables\n\ntable: Name of the table.\nfields: List of Field(name, transform) – columns and how to compute them.\njoin_keys: List of transforms for unique row IDs (like primary keys). Same keys across traversals merge rows.\n\n\n\n5. Executor: Running It All\nrun_mapping(json_data, spec) executes everything and returns a dict of tables.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#detailed-examples",
    "href": "index.html#detailed-examples",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Detailed Examples",
    "text": "Detailed Examples\n\nExample 1: Composite Keys for Merging Data\nMerge user info from two parts of JSON:\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(  # Basic user data\n        path=[\"users\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",\n            join_keys=[get(\"id\")],\n            fields=[Field(\"id\", get(\"id\")), Field(\"name\", get(\"name\"))]\n        )]\n    ),\n    TraversalSpec(  # Add email from another section\n        path=[\"profiles\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"users\",  # Same table!\n            join_keys=[get(\"user_id\")],  # Matches previous keys\n            fields=[Field(\"email\", get(\"email\"))]\n        )]\n    )\n])\n\nRows with matching keys merge: e.g., add “email” to existing user row.\n\n\nExample 2: Deep Nesting (Arbitrary Depth)\nNo limit to depth—use longer inner_path. The depth parameter controls how many levels up to look:\n\nget_from_parent(\"id\") or depth=1 → immediate parent\nget_from_parent(\"id\", depth=2) → grandparent\nget_from_parent(\"id\", depth=3) → great-grandparent\n\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"servers\"],\n        mode=\"auto\",\n        inner_path=[\"channels\", \"messages\", \"reactions\"],  # 3 levels deep!\n        inner_mode=\"auto\",\n        emits=[TableEmit(\n            table=\"reactions\",\n            join_keys=[get_from_parent(\"id\", depth=3), get_from_parent(\"id\", depth=2), get_from_parent(\"id\"), get(\"id\")],\n            fields=[\n                Field(\"server_id\", get_from_parent(\"id\", depth=3)),\n                Field(\"channel_id\", get_from_parent(\"id\", depth=2)),\n                Field(\"message_id\", get_from_parent(\"id\")),\n                Field(\"reaction\", get(\"emoji\"))\n            ]\n        )]\n    )\n])",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#transform-cheatsheet",
    "href": "index.html#transform-cheatsheet",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Transform Cheatsheet",
    "text": "Transform Cheatsheet\n\nget(path): From current node (dot notation or list, e.g., “user.name” or [“user”, 0]).\nget_from_parent(path, depth=1): From ancestor.\nget_from_root(path): From top-level JSON.\nkey(): Current dict key.\nindex(): Current list index.\nliteral(value): Constant value.\nconcat(*parts): Join strings.\nformat_id(*parts, sep=\"_\"): Join non-empty parts with separator.\ncoalesce(*transforms): First non-None value.\nlen_of(inner): Length of a list/dict/string.\n\nPro Tip: Transforms are lazy—they run in the “context” of where they’re used, making them super flexible.\nTransforms compose naturally:\n\nuser_key = concat(literal(\"user_\"), get(\"id\"))           # \"user_123\"\nfull_name = concat(get(\"first\"), literal(\" \"), get(\"last\"))  # \"Alice Smith\"",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#common-mistakes",
    "href": "index.html#common-mistakes",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Common Mistakes",
    "text": "Common Mistakes\n\nEmpty results?\n\nCheck your path matches the JSON structure exactly\nVerify the data type at that path matches expectations\n\nMissing parent data?\n\nCheck the depth parameter in get_from_parent()\nEnsure the parent context exists in your traversal\n\nDuplicate or missing rows?\n\nVerify join_keys are unique for each row\nCheck that join_keys don’t contain None values (these rows are skipped)",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#advanced-topics",
    "href": "index.html#advanced-topics",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Advanced Topics",
    "text": "Advanced Topics\n\nLazy Evaluation: Transforms don’t compute until executed, adapting to the current spot in JSON.\nCustom Transforms: Define your own functions that take Context and return values. See Transforms.\nRow Merging Rules: Last write wins for duplicate fields; missing keys skip rows.\nType-safe field selectors: IDE autocomplete and compile-time typo detection. See Developing with etielle.\nTyped emissions: Build Pydantic/TypedDict/ORM instances directly instead of dicts. See Emissions.\nMerge policies: Sum/append/min/max instead of overwrite when multiple traversals update the same field. See Emissions.\nError reporting: Per-key diagnostics in results. See Developing with etielle.\nRelationships without extra round trips: Bind in-memory, flush once. See Relationships and Database upserts.\nPerformance: Efficient for large JSON; traversals are independent.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#roadmap-ideas",
    "href": "index.html#roadmap-ideas",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Roadmap Ideas",
    "text": "Roadmap Ideas\n\nDatabase integrations (e.g., SQLAlchemy).\nMore examples and benchmarks.\nVisual mapping tools.",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#glossary",
    "href": "index.html#glossary",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "Glossary",
    "text": "Glossary\n\nContext: Your current position while traversing the JSON tree\nTransform: A function that extracts values from a Context\nTraversal: Instructions for walking through part of the JSON\nEmit: Creating a table row from the current context\nJoin keys: Values that uniquely identify a row (like primary keys)\nDepth: How many parent levels to traverse upward",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Quickstart: Declarative JSON-to-Relational Mapping in Python with etielle",
    "section": "License",
    "text": "License\nMIT\nNeed help? Open an issue on GitHub!",
    "crumbs": [
      "Quickstart"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html",
    "href": "docs/loading-data-into-a-database.html",
    "title": "Database Upserts: Loading Data",
    "section": "",
    "text": "What you’ll learn: How to efficiently persist mapped data to SQLAlchemy or SQLModel databases with one-shot flushing and relationship binding.\nETL context: This is the Load step—persisting your transformed in-memory objects to a database.",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#overview",
    "href": "docs/loading-data-into-a-database.html#overview",
    "title": "Database Upserts: Loading Data",
    "section": "Overview",
    "text": "Overview\netielle’s database adapters build on the relationship system to provide:\n\nOne-shot flushing: Insert all rows in minimal database operations\nRelationship binding: Link parent-child records before persistence\nORM integration: Works with SQLAlchemy and SQLModel",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#installation",
    "href": "docs/loading-data-into-a-database.html#installation",
    "title": "Database Upserts: Loading Data",
    "section": "Installation",
    "text": "Installation\nInstall the optional extra for your ORM:\n\nSQLAlchemySQLModel\n\n\nuv add \"etielle[sqlalchemy]\"\n# or\npip install \"etielle[sqlalchemy]\"\n\n\nuv add \"etielle[sqlmodel]\"\n# or\npip install \"etielle[sqlmodel]\"",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#why-one-shot-flushing",
    "href": "docs/loading-data-into-a-database.html#why-one-shot-flushing",
    "title": "Database Upserts: Loading Data",
    "section": "Why One-Shot Flushing?",
    "text": "Why One-Shot Flushing?\nTraditional ORM approach (multiple round trips):\n\nInsert parent record → wait for database to assign ID\nQuery to get the ID back\nInsert child record with foreign key\nRepeat for each parent-child pair\nResult: N+1 queries (or worse)\n\netielle one-shot approach (single flush):\n\nCreate all parent instances in memory\nCreate all child instances in memory\nLink children to parents using Python object references\nCall session.flush() once → ORM inserts everything\nResult: 1-2 database operations\n\nFor 1000 users with 10 posts each, this is typically 10-100x faster.",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#quick-start",
    "href": "docs/loading-data-into-a-database.html#quick-start",
    "title": "Database Upserts: Loading Data",
    "section": "Quick Start",
    "text": "Quick Start\n\nSQLAlchemySQLModel\n\n\n\nfrom sqlalchemy import String, ForeignKey, create_engine\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, Session\nfrom etielle.core import MappingSpec, TraversalSpec\nfrom etielle.transforms import get\nfrom etielle.instances import InstanceEmit, FieldSpec, ConstructorBuilder\nfrom etielle.relationships import ManyToOneSpec\nfrom etielle.adapters.sqlalchemy_adapter import bind_and_flush\n\n# Define models\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[str] = mapped_column(String, primary_key=True)\n    name: Mapped[str] = mapped_column(String)\n    posts: Mapped[list[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[str] = mapped_column(String, primary_key=True)\n    title: Mapped[str] = mapped_column(String)\n    user_id: Mapped[str | None] = mapped_column(String, ForeignKey(\"users.id\"), nullable=True)\n    user: Mapped[User | None] = relationship(back_populates=\"posts\")\n\n# Setup database\nengine = create_engine(\"sqlite+pysqlite:///:memory:\")\nBase.metadata.create_all(engine)\nsession = Session(engine)\n\n# JSON data\ndata = {\n    \"users\": [\n        {\"id\": \"u1\", \"name\": \"Alice\"},\n        {\"id\": \"u2\", \"name\": \"Bob\"},\n    ],\n    \"posts\": [\n        {\"id\": \"p1\", \"title\": \"Hello\", \"user_id\": \"u1\"},\n        {\"id\": \"p2\", \"title\": \"World\", \"user_id\": \"u2\"},\n    ],\n}\n\n# Define emissions using ConstructorBuilder for ORM objects\nusers_emit = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=\"id\", transform=get(\"id\")),\n        FieldSpec(selector=\"name\", transform=get(\"name\")),\n    ],\n    builder=ConstructorBuilder(User),\n)\n\nposts_emit = InstanceEmit[Post](\n    table=\"posts\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=\"id\", transform=get(\"id\")),\n        FieldSpec(selector=\"title\", transform=get(\"title\")),\n    ],\n    builder=ConstructorBuilder(Post),\n)\n\n# Define mapping\nmapping = MappingSpec(\n    traversals=[\n        TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[users_emit]),\n        TraversalSpec(path=[\"posts\"], mode=\"auto\", emits=[posts_emit]),\n    ]\n)\n\n# Define relationships\nrelationships = [\n    ManyToOneSpec(\n        child_table=\"posts\",\n        parent_table=\"users\",\n        attr=\"user\",  # The relationship attribute on Post\n        child_to_parent_key=[get(\"user_id\")],  # How to find the parent\n        required=True,\n    )\n]\n\n# One-shot bind and flush\nresults = bind_and_flush(\n    session,\n    root=data,\n    mapping=mapping,\n    relationships=relationships,\n    add_all_instances=True,\n)\n\nprint(f\"Users: {len(results['users'].instances)}, Posts: {len(results['posts'].instances)}\")\n\nUsers: 2, Posts: 2\n\n\n\n\n\nfrom sqlmodel import SQLModel, Field, Relationship, Session, create_engine, select\nfrom etielle.core import MappingSpec, TraversalSpec\nfrom etielle.transforms import get\nfrom etielle.instances import InstanceEmit, FieldSpec, ConstructorBuilder\nfrom etielle.relationships import ManyToOneSpec\nfrom etielle.adapters.sqlmodel_adapter import bind_and_flush\n\n# Define models\nclass User(SQLModel, table=True):\n    __tablename__ = \"sm_users\"\n    id: str = Field(primary_key=True)\n    name: str\n    posts: list[\"Post\"] = Relationship(back_populates=\"user\")\n\nclass Post(SQLModel, table=True):\n    __tablename__ = \"sm_posts\"\n    id: str = Field(primary_key=True)\n    title: str\n    user_id: str | None = Field(default=None, foreign_key=\"sm_users.id\")\n    user: User | None = Relationship(back_populates=\"posts\")\n\n# Setup database\nengine = create_engine(\"sqlite+pysqlite:///:memory:\")\nSQLModel.metadata.create_all(engine)\nsession = Session(engine)\n\n# JSON data\ndata = {\n    \"users\": [\n        {\"id\": \"u1\", \"name\": \"Alice\"},\n        {\"id\": \"u2\", \"name\": \"Bob\"},\n    ],\n    \"posts\": [\n        {\"id\": \"p1\", \"title\": \"Hello\", \"user_id\": \"u1\"},\n        {\"id\": \"p2\", \"title\": \"World\", \"user_id\": \"u2\"},\n    ],\n}\n\n# Same pattern as SQLAlchemy\nusers_emit = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=\"id\", transform=get(\"id\")),\n        FieldSpec(selector=\"name\", transform=get(\"name\")),\n    ],\n    builder=ConstructorBuilder(User),\n)\n\nposts_emit = InstanceEmit[Post](\n    table=\"posts\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=\"id\", transform=get(\"id\")),\n        FieldSpec(selector=\"title\", transform=get(\"title\")),\n    ],\n    builder=ConstructorBuilder(Post),\n)\n\nmapping = MappingSpec(\n    traversals=[\n        TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[users_emit]),\n        TraversalSpec(path=[\"posts\"], mode=\"auto\", emits=[posts_emit]),\n    ]\n)\n\nrelationships = [\n    ManyToOneSpec(\n        child_table=\"posts\",\n        parent_table=\"users\",\n        attr=\"user\",\n        child_to_parent_key=[get(\"user_id\")],\n        required=True,\n    )\n]\n\nresults = bind_and_flush(\n    session,\n    root=data,\n    mapping=mapping,\n    relationships=relationships,\n    add_all_instances=True,\n)\n\nprint(f\"Users: {len(results['users'].instances)}, Posts: {len(results['posts'].instances)}\")\n\nUsers: 2, Posts: 2",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#constructorbuilder-for-orm-objects",
    "href": "docs/loading-data-into-a-database.html#constructorbuilder-for-orm-objects",
    "title": "Database Upserts: Loading Data",
    "section": "ConstructorBuilder for ORM Objects",
    "text": "ConstructorBuilder for ORM Objects\nWhen working with ORM models, use ConstructorBuilder instead of PydanticBuilder:\nfrom etielle.instances import ConstructorBuilder\n\n# ConstructorBuilder calls User(**fields) to create instances\nbuilder = ConstructorBuilder(User)\nThis works because SQLAlchemy and SQLModel models accept keyword arguments in their constructors.\nWhen to use each builder:\n\n\n\nBuilder\nUse case\n\n\n\n\nPydanticBuilder\nPure Pydantic models (not ORM)\n\n\nConstructorBuilder\nSQLAlchemy/SQLModel ORM models\n\n\nTypedDictBuilder\nPlain dictionaries",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#relationship-binding",
    "href": "docs/loading-data-into-a-database.html#relationship-binding",
    "title": "Database Upserts: Loading Data",
    "section": "Relationship Binding",
    "text": "Relationship Binding\nRelationships are defined with ManyToOneSpec:\nfrom etielle.relationships import ManyToOneSpec\nfrom etielle.transforms import get\n\nManyToOneSpec(\n    child_table=\"posts\",      # Table with the foreign key\n    parent_table=\"users\",     # Table being referenced\n    attr=\"user\",              # Relationship attribute on child model\n    child_to_parent_key=[     # Transform(s) to find the parent's join_key\n        get(\"user_id\")\n    ],\n    required=True,            # Error if parent not found\n)\n\nHow it Works\n\nCompute keys: etielle traverses the JSON again to compute which child belongs to which parent\nStore in sidecar: Relationships are stored separately from instances\nBind in memory: Child objects are linked to parent objects via Python references\nFlush once: SQLAlchemy/SQLModel handles foreign keys automatically\n\n\n\nNested Data Example\nWhen parent-child data is nested in the JSON:\ndata = {\n    \"users\": [\n        {\"id\": \"u1\", \"name\": \"Alice\", \"posts\": [\n            {\"id\": \"p1\", \"title\": \"Hello\"},\n            {\"id\": \"p2\", \"title\": \"World\"}\n        ]}\n    ]\n}\n\n# Use get_from_parent to reference the parent's ID\nrelationships = [\n    ManyToOneSpec(\n        child_table=\"posts\",\n        parent_table=\"users\",\n        attr=\"user\",\n        child_to_parent_key=[get_from_parent(\"id\")],  # Get ID from parent context\n    )\n]",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#before-flush-hook",
    "href": "docs/loading-data-into-a-database.html#before-flush-hook",
    "title": "Database Upserts: Loading Data",
    "section": "Before-Flush Hook",
    "text": "Before-Flush Hook\nFor fine-grained control over transactions, use install_before_flush_binder:\n\nSQLAlchemySQLModel\n\n\nfrom etielle.adapters.sqlalchemy_adapter import install_before_flush_binder\n\ninstall_before_flush_binder(\n    session,\n    root=data,\n    mapping=mapping,\n    relationships=relationships,\n)\n\n# Do other session work...\n# Binding happens automatically when you flush\nsession.flush()\n\n\nfrom etielle.adapters.sqlmodel_adapter import install_before_flush_binder\n\ninstall_before_flush_binder(\n    session,\n    root=data,\n    mapping=mapping,\n    relationships=relationships,\n)\n\nsession.flush()",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#api-reference",
    "href": "docs/loading-data-into-a-database.html#api-reference",
    "title": "Database Upserts: Loading Data",
    "section": "API Reference",
    "text": "API Reference\n\nbind_and_flush\ndef bind_and_flush(\n    session: Session,\n    root: Any,                      # The JSON data\n    mapping: MappingSpec,           # Your mapping specification\n    relationships: list[ManyToOneSpec],  # Relationship definitions\n    add_all_instances: bool = True,  # Add instances to session\n) -&gt; dict[str, MappingResult]:\n\n\ninstall_before_flush_binder\ndef install_before_flush_binder(\n    session: Session,\n    root: Any,\n    mapping: MappingSpec,\n    relationships: list[ManyToOneSpec],\n) -&gt; None:\n\n\nManyToOneSpec\n\n\n\n\n\n\n\n\nParameter\nType\nDescription\n\n\n\n\nchild_table\nstr\nName of the child table (has foreign key)\n\n\nparent_table\nstr\nName of the parent table (referenced)\n\n\nattr\nstr\nRelationship attribute name on child model\n\n\nchild_to_parent_key\nlist[Transform]\nTransforms to compute parent’s join_key\n\n\nrequired\nbool\nIf True, missing parent is an error",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#performance-notes",
    "href": "docs/loading-data-into-a-database.html#performance-notes",
    "title": "Database Upserts: Loading Data",
    "section": "Performance Notes",
    "text": "Performance Notes\n\nAutoflush is temporarily disabled during one-shot operations\nInstances are added and flushed once; ORMs populate FKs via relationships\nFor very large datasets, consider batching (chunking the JSON input)",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/loading-data-into-a-database.html#see-also",
    "href": "docs/loading-data-into-a-database.html#see-also",
    "title": "Database Upserts: Loading Data",
    "section": "See also",
    "text": "See also\n\nRelationships - In-memory relationship binding without database\nEmissions - Creating the instances that get loaded",
    "crumbs": [
      "Database upserts"
    ]
  },
  {
    "objectID": "docs/transforms.html",
    "href": "docs/transforms.html",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "",
    "text": "What you’ll learn: How to use transforms to extract, format, and combine values from JSON data, including how to write custom transforms.\nETL context: Transforms are field-level data extraction—the first part of the Transform step.",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#what-is-a-transform",
    "href": "docs/transforms.html#what-is-a-transform",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "What is a Transform?",
    "text": "What is a Transform?\nA transform is a function that takes a Context (your current position in the JSON tree) and returns a value. They’re “lazy”—they don’t compute until executed, and they adapt to wherever you are in the traversal.\nfrom etielle.transforms import get\n\n# A transform doesn't run immediately—it's a \"recipe\"\nname_transform = get(\"name\")\n\n# It runs when applied to a Context during traversal\n# and returns the value at ctx.node[\"name\"]",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#the-context-object",
    "href": "docs/transforms.html#the-context-object",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "The Context Object",
    "text": "The Context Object\nEvery transform receives a Context that represents your current position:\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nroot\nAny\nThe entire original JSON payload\n\n\nnode\nAny\nThe current item being processed\n\n\npath\ntuple[str, int, ...]\nPath from root to current node (e.g., (\"users\", 0))\n\n\nparent\nContext or None\nThe parent context (one level up in the traversal)\n\n\nkey\nstr or None\nCurrent dict key when iterating mappings\n\n\nindex\nint or None\nCurrent list index when iterating sequences\n\n\nslots\ndict[str, Any]\nScratchpad for intermediate values",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#built-in-transforms",
    "href": "docs/transforms.html#built-in-transforms",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "Built-in Transforms",
    "text": "Built-in Transforms\n\nValue Extraction\n\nget(path) — Get from current node\nfrom etielle.transforms import get\n\nget(\"name\")                    # ctx.node[\"name\"]\nget(\"user.email\")              # ctx.node[\"user\"][\"email\"] (dot notation)\nget([\"user\", \"addresses\", 0])  # ctx.node[\"user\"][\"addresses\"][0]\nget([])                        # ctx.node (the current node itself)\n\n\nget_from_parent(path, depth=1) — Get from ancestor\nfrom etielle.transforms import get_from_parent\n\nget_from_parent(\"id\")           # Parent's \"id\" field\nget_from_parent(\"id\", depth=2)  # Grandparent's \"id\" field\nget_from_parent(\"id\", depth=3)  # Great-grandparent's \"id\" field\n\n\nget_from_root(path) — Get from document root\nfrom etielle.transforms import get_from_root\n\nget_from_root(\"metadata.version\")  # Always from the original JSON root\nget_from_root(\"config.api_key\")    # Useful for global values\n\n\n\nContext Position\n\nkey() — Current dict key\nfrom etielle.transforms import key\n\n# When iterating {\"alice\": {...}, \"bob\": {...}}:\nkey()  # Returns \"alice\", then \"bob\"\n\n\nindex() — Current list index\nfrom etielle.transforms import index\n\n# When iterating [item0, item1, item2]:\nindex()  # Returns 0, then 1, then 2\n\n\nparent_key(depth=1) — Parent’s dict key\nfrom etielle.transforms import parent_key\n\nparent_key()        # Key from immediate parent iteration\nparent_key(depth=2)  # Key from grandparent iteration\n\n\n\nValue Generation\n\nliteral(value) — Constant value\nfrom etielle.transforms import literal\n\nliteral(\"active\")     # Always returns \"active\"\nliteral(42)           # Always returns 42\nliteral(None)         # Always returns None\n\n\n\nString Composition\n\nconcat(*parts) — Join strings\nfrom etielle.transforms import concat, get, literal\n\nconcat(\"Hello, \", get(\"name\"), \"!\")\n# Result: \"Hello, Alice!\" when name is \"Alice\"\n\nconcat(get(\"first\"), literal(\" \"), get(\"last\"))\n# Result: \"Ada Lovelace\"\n\n\nformat_id(*parts, sep=\"_\") — Join with separator, skip nulls\nfrom etielle.transforms import format_id, get\n\nformat_id(get(\"prefix\"), get(\"id\"), sep=\"-\")\n# Result: \"user-123\" (skips None/empty values)\n\nformat_id(literal(\"row\"), index(), get(\"type\"))\n# Result: \"row_0_order\" when index=0 and type=\"order\"\n\n\n\nUtilities\n\ncoalesce(*transforms) — First non-None value\nfrom etielle.transforms import coalesce, get\n\ncoalesce(get(\"nickname\"), get(\"username\"), get(\"email\"))\n# Returns the first non-None value found\n\n\nlen_of(inner) — Length of a value\nfrom etielle.transforms import len_of, get\n\nlen_of(get(\"tags\"))       # Number of items in the tags array\nlen_of(get(\"name\"))       # Length of the name string",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#complete-example",
    "href": "docs/transforms.html#complete-example",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "Complete Example",
    "text": "Complete Example\n\nfrom etielle.core import MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get, get_from_root, get_from_parent, key, index, parent_key, literal, concat, format_id, coalesce\nfrom etielle.executor import run_mapping\nimport json\n\ndata = {\n    \"company\": \"Acme Corp\",\n    \"departments\": {\n        \"engineering\": {\n            \"employees\": [\n                {\"id\": \"e1\", \"name\": \"Alice\", \"nickname\": None},\n                {\"id\": \"e2\", \"name\": \"Bob\", \"nickname\": \"Bobby\"}\n            ]\n        },\n        \"sales\": {\n            \"employees\": [\n                {\"id\": \"e3\", \"name\": \"Carol\", \"nickname\": \"C\"}\n            ]\n        }\n    }\n}\n\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"departments\"],\n        mode=\"items\",  # Iterate dept key-value pairs\n        inner_path=[\"employees\"],\n        inner_mode=\"auto\",\n        emits=[TableEmit(\n            table=\"employees\",\n            join_keys=[get(\"id\")],\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"name\", get(\"name\")),\n                Field(\"display_name\", coalesce(get(\"nickname\"), get(\"name\"))),\n                Field(\"department\", parent_key()),  # \"engineering\" or \"sales\"\n                Field(\"company\", get_from_root(\"company\")),\n                Field(\"full_id\", format_id(parent_key(), get(\"id\"), sep=\"-\")),\n            ]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nprint(json.dumps(list(result[\"employees\"].instances.values()), indent=2))\n\n[\n  {\n    \"id\": \"e1\",\n    \"name\": \"Alice\",\n    \"display_name\": \"Alice\",\n    \"department\": \"engineering\",\n    \"company\": \"Acme Corp\",\n    \"full_id\": \"engineering-e1\"\n  },\n  {\n    \"id\": \"e2\",\n    \"name\": \"Bob\",\n    \"display_name\": \"Bobby\",\n    \"department\": \"engineering\",\n    \"company\": \"Acme Corp\",\n    \"full_id\": \"engineering-e2\"\n  },\n  {\n    \"id\": \"e3\",\n    \"name\": \"Carol\",\n    \"display_name\": \"C\",\n    \"department\": \"sales\",\n    \"company\": \"Acme Corp\",\n    \"full_id\": \"sales-e3\"\n  }\n]",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#writing-custom-transforms",
    "href": "docs/transforms.html#writing-custom-transforms",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "Writing Custom Transforms",
    "text": "Writing Custom Transforms\nA transform is any callable with signature (Context) -&gt; T. You can write your own:\n\nSimple Custom Transform\nfrom etielle.core import Context\n\ndef uppercase_name(ctx: Context) -&gt; str | None:\n    \"\"\"Extract and uppercase the name field.\"\"\"\n    name = ctx.node.get(\"name\")\n    return name.upper() if name else None\n\n\nTransform Using Context Fields\nfrom etielle.core import Context\n\ndef full_path_string(ctx: Context) -&gt; str:\n    \"\"\"Return the full JSON path as a string.\"\"\"\n    return \".\".join(str(p) for p in ctx.path)\n\ndef is_first_item(ctx: Context) -&gt; bool:\n    \"\"\"Check if this is the first item in a list.\"\"\"\n    return ctx.index == 0\n\n\nTransform with External State (Closures)\nUse closures to create transforms that reference external data. This is powerful for lookups and cross-referencing:\nfrom etielle.core import Context\nfrom etielle.transforms import Transform\n\ndef make_lookup_transform(lookup_dict: dict[str, str]) -&gt; Transform[str | None]:\n    \"\"\"Create a transform that looks up values in an external dict.\"\"\"\n    def lookup(ctx: Context) -&gt; str | None:\n        key = ctx.node.get(\"foreign_id\")\n        return lookup_dict.get(key)\n    return lookup\n\n# Build lookup from some source\nid_to_category = {\"p1\": \"electronics\", \"p2\": \"clothing\", \"p3\": \"electronics\"}\n\n# Create the transform\nget_category = make_lookup_transform(id_to_category)\n\n# Use in a field\n# Field(\"category\", get_category)\n\n\nTransform Composition\nTransforms compose naturally—the output of one can feed into another:\nfrom etielle.core import Context\nfrom etielle.transforms import get\n\ndef trim_and_lower(inner: Transform) -&gt; Transform[str | None]:\n    \"\"\"Compose: apply inner transform, then trim and lowercase.\"\"\"\n    def composed(ctx: Context) -&gt; str | None:\n        value = inner(ctx)\n        if isinstance(value, str):\n            return value.strip().lower()\n        return None\n    return composed\n\n# Usage:\n# Field(\"normalized_email\", trim_and_lower(get(\"email\")))\n\n\nPrecomputed Index Example\nA common pattern is building an index from the JSON before mapping, then using it in transforms:\n\nfrom etielle.core import Context, MappingSpec, TraversalSpec, TableEmit, Field\nfrom etielle.transforms import get, get_from_parent\nfrom etielle.executor import run_mapping\nimport json\n\n# Complex JSON with relationships defined elsewhere\ndata = {\n    \"categories\": [\n        {\"id\": \"cat1\", \"name\": \"Electronics\"},\n        {\"id\": \"cat2\", \"name\": \"Clothing\"}\n    ],\n    \"products\": [\n        {\"id\": \"p1\", \"name\": \"Phone\", \"category_id\": \"cat1\"},\n        {\"id\": \"p2\", \"name\": \"Shirt\", \"category_id\": \"cat2\"},\n        {\"id\": \"p3\", \"name\": \"Laptop\", \"category_id\": \"cat1\"}\n    ]\n}\n\n# Step 1: Build index from the JSON\ncategory_names = {\n    cat[\"id\"]: cat[\"name\"]\n    for cat in data[\"categories\"]\n}\n\n# Step 2: Create transform that uses the index\ndef get_category_name(ctx: Context) -&gt; str | None:\n    category_id = ctx.node.get(\"category_id\")\n    return category_names.get(category_id)\n\n# Step 3: Use in mapping\nspec = MappingSpec(traversals=[\n    TraversalSpec(\n        path=[\"products\"],\n        mode=\"auto\",\n        emits=[TableEmit(\n            table=\"products\",\n            join_keys=[get(\"id\")],\n            fields=[\n                Field(\"id\", get(\"id\")),\n                Field(\"name\", get(\"name\")),\n                Field(\"category_id\", get(\"category_id\")),\n                Field(\"category_name\", get_category_name),  # Custom transform!\n            ]\n        )]\n    )\n])\n\nresult = run_mapping(data, spec)\nprint(json.dumps(list(result[\"products\"].instances.values()), indent=2))\n\n[\n  {\n    \"id\": \"p1\",\n    \"name\": \"Phone\",\n    \"category_id\": \"cat1\",\n    \"category_name\": \"Electronics\"\n  },\n  {\n    \"id\": \"p2\",\n    \"name\": \"Shirt\",\n    \"category_id\": \"cat2\",\n    \"category_name\": \"Clothing\"\n  },\n  {\n    \"id\": \"p3\",\n    \"name\": \"Laptop\",\n    \"category_id\": \"cat1\",\n    \"category_name\": \"Electronics\"\n  }\n]",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#best-practices",
    "href": "docs/transforms.html#best-practices",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "Best Practices",
    "text": "Best Practices\n\nKeep Transforms Pure\nTransforms should be side-effect free:\n# Good: Pure function\ndef get_uppercase_name(ctx: Context) -&gt; str | None:\n    name = ctx.node.get(\"name\")\n    return name.upper() if name else None\n\n# Bad: Side effects\ncounter = 0\ndef counted_name(ctx: Context) -&gt; str:\n    global counter\n    counter += 1  # Side effect!\n    return ctx.node.get(\"name\")\n\n\nHandle Missing Values Defensively\nReturn None instead of raising exceptions:\n# Good: Defensive\ndef safe_get_nested(ctx: Context) -&gt; str | None:\n    try:\n        return ctx.node[\"deeply\"][\"nested\"][\"value\"]\n    except (KeyError, TypeError):\n        return None\n\n# Bad: May raise\ndef unsafe_get_nested(ctx: Context) -&gt; str:\n    return ctx.node[\"deeply\"][\"nested\"][\"value\"]  # Raises if missing!\n\n\nDocument Complex Transforms\ndef compute_composite_key(ctx: Context) -&gt; str | None:\n    \"\"\"\n    Builds a composite key for order items.\n\n    Format: {order_id}_{line_number}\n    Returns None if order_id is missing (row will be skipped).\n    \"\"\"\n    order_id = ctx.parent.node.get(\"id\") if ctx.parent else None\n    line_num = ctx.index\n    if order_id is None:\n        return None\n    return f\"{order_id}_{line_num}\"",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#transform-reference",
    "href": "docs/transforms.html#transform-reference",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "Transform Reference",
    "text": "Transform Reference\n\n\n\n\n\n\n\n\nTransform\nSignature\nDescription\n\n\n\n\nget(path)\nstr or list → Any\nGet from current node\n\n\nget_from_parent(path, depth)\nstr or list, int → Any\nGet from ancestor\n\n\nget_from_root(path)\nstr or list → Any\nGet from document root\n\n\nkey()\n→ str or None\nCurrent dict key\n\n\nindex()\n→ int or None\nCurrent list index\n\n\nparent_key(depth)\nint → str or None\nParent’s dict key\n\n\nliteral(value)\nT → T\nConstant value\n\n\nconcat(*parts)\n*str → str\nJoin strings\n\n\nformat_id(*parts, sep)\n*str, str → str\nJoin with separator, skip nulls\n\n\ncoalesce(*inners)\n*Transform → Any\nFirst non-None value\n\n\nlen_of(inner)\nTransform → int or None\nLength of a value",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/transforms.html#see-also",
    "href": "docs/transforms.html#see-also",
    "title": "Transforms: Extracting and Reshaping Values",
    "section": "See also",
    "text": "See also\n\nTraversals - Where transforms execute in the JSON structure\nEmissions - Using transforms in TableEmit and InstanceEmit",
    "crumbs": [
      "Transforms"
    ]
  },
  {
    "objectID": "docs/developing-with-etielle.html",
    "href": "docs/developing-with-etielle.html",
    "title": "Developing with etielle",
    "section": "",
    "text": "What you’ll learn: Developer experience features including error reporting, debugging, and type-safe field selectors.\nThis page covers the tooling that makes etielle easier to develop with: error diagnostics, debugging workflows, and type safety features.",
    "crumbs": [
      "Developing with etielle"
    ]
  },
  {
    "objectID": "docs/developing-with-etielle.html#error-reporting",
    "href": "docs/developing-with-etielle.html#error-reporting",
    "title": "Developing with etielle",
    "section": "Error Reporting",
    "text": "Error Reporting\netielle aggregates errors with precise context and returns them alongside your instances.\n\nResult Shape\nEvery run_mapping() call returns a dict of MappingResult objects:\nfrom etielle.core import MappingResult\n\n# MappingResult[T] contains:\n# - instances: Dict[tuple, T]           # Successful instances keyed by join_keys\n# - update_errors: Dict[tuple, list[str]]  # Errors during field updates\n# - finalize_errors: Dict[tuple, list[str]]  # Errors during instance construction\n# - stats: Dict[str, int]               # Summary statistics\n\n\nError Types\nUpdate errors happen during field updates:\n\n\n\n\n\n\n\n\nError\nCause\nFix\n\n\n\n\nUnknown field\nReferenced a field that doesn’t exist\nCheck spelling, add field to model\n\n\nType mismatch\nMerge policy expected different type\nEnsure transforms return correct type\n\n\nMerge failure\nPolicy couldn’t combine values\nCheck field initialization\n\n\n\nFinalize errors happen during instance construction:\n\n\n\n\n\n\n\n\nError\nCause\nFix\n\n\n\n\nMissing required field\nModel requires a field that wasn’t set\nAdd FieldSpec or make optional\n\n\nValidation error\nPydantic validation failed\nCheck transform outputs match field types\n\n\n\n\n\nDebugging Workflow\n\nfrom etielle.core import MappingSpec, TraversalSpec\nfrom etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder\nfrom etielle.transforms import get\nfrom etielle.executor import run_mapping\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    email: str\n\nroot = {\"users\": [{\"id\": \"u1\", \"email\": \"alice@example.com\"}]}\n\n# Intentional typo to demonstrate error handling\nemit = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=\"id\", transform=get(\"id\")),\n        FieldSpec(selector=\"emali\", transform=get(\"email\")),  # Typo!\n    ],\n    builder=PydanticBuilder(User),\n)\n\nmapping = MappingSpec(traversals=[TraversalSpec(path=[\"users\"], mode=\"auto\", emits=[emit])])\nresult = run_mapping(root, mapping)\n\n# Step 1: Check stats\nprint(\"Stats:\", result[\"users\"].stats)\n\n# Step 2: Inspect update errors\nfor key, errors in result[\"users\"].update_errors.items():\n    print(f\"Row {key} update errors: {errors}\")\n\n# Step 3: Inspect finalize errors\nfor key, errors in result[\"users\"].finalize_errors.items():\n    print(f\"Row {key} finalize errors: {errors}\")\n\nStats: {'num_instances': 0, 'num_update_errors': 1, 'num_finalize_errors': 1}\nRow ('u1',) update errors: [\"table=users key=('u1',) field emali: unknown field; did you mean email?\"]\nRow ('u1',) finalize errors: [\"table=users key=('u1',) 1 validation error for User\\nemail\\n  Field required [type=missing, input_value={'id': 'u1'}, input_type=dict]\\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\"]\n\n\n\n\nUnknown Field Suggestions\nWhen using string field names with a typo, etielle suggests corrections:\nUnknown field 'emali' for table 'users'. Did you mean: 'email'?\n\n\nStrictness Modes\nControl how unknown fields are handled:\nemit = InstanceEmit[User](\n    table=\"users\",\n    # ...\n    strict_fields=True,      # Check field names (default)\n    strict_mode=\"collect\",   # Collect errors (default)\n    # strict_mode=\"fail_fast\",  # Raise immediately instead\n)",
    "crumbs": [
      "Developing with etielle"
    ]
  },
  {
    "objectID": "docs/developing-with-etielle.html#field-selectors",
    "href": "docs/developing-with-etielle.html#field-selectors",
    "title": "Developing with etielle",
    "section": "Field Selectors",
    "text": "Field Selectors\nField selectors provide type-safe field references that your IDE and type checker can verify.\n\nBasic Usage\n\nfrom etielle.core import field_of\n\nclass User:\n    id: str\n    email: str\n\n# Returns \"email\" at runtime, type-checked at development time\nprint(field_of(User, lambda u: u.email))\n\nemail\n\n\n\n\nBenefits\n\nIDE autocomplete: Your editor suggests available fields\nType-check errors: Typos caught before running\nRefactoring safety: Renaming a field updates all references\n\n\n\nUsage in InstanceEmit\n\nfrom etielle.core import field_of\nfrom etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder\nfrom etielle.transforms import get\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    email: str\n\nemit = InstanceEmit[User](\n    table=\"users\",\n    join_keys=[get(\"id\")],\n    fields=[\n        FieldSpec(selector=field_of(User, lambda u: u.id), transform=get(\"id\")),\n        FieldSpec(selector=field_of(User, lambda u: u.email), transform=get(\"email\")),\n    ],\n    builder=PydanticBuilder(User),\n)\n\n\n\nConstraints\nThe field_of() function enforces:\n\nExactly one attribute access\nNo method calls\nNo indexing\nNo chained attributes\n\n\nfrom etielle.core import field_of\n\nclass Model:\n    x: int\n\n# OK\nprint(field_of(Model, lambda m: m.x))\n\n# Would raise ValueError: method call\ntry:\n    field_of(Model, lambda m: m.x.__str__())\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Would raise ValueError: chained access\ntry:\n    field_of(Model, lambda m: m.x.real)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\nx\nError: Invalid field selector: stringification of attribute selector at 'x'\nError: The selector must access exactly one attribute; got chained path 'x.real'\n\n\n\n\nWhen to Use What\n\n\n\n\n\n\n\nUse field_of() selectors\nUse string field names\n\n\n\n\nPydantic models, dataclasses, typed classes\nPlain dicts, dynamic data\n\n\nUsing a type checker (mypy, pyright)\nPrototyping quickly\n\n\nWant IDE autocomplete\nField names computed at runtime",
    "crumbs": [
      "Developing with etielle"
    ]
  },
  {
    "objectID": "docs/developing-with-etielle.html#common-debugging-scenarios",
    "href": "docs/developing-with-etielle.html#common-debugging-scenarios",
    "title": "Developing with etielle",
    "section": "Common Debugging Scenarios",
    "text": "Common Debugging Scenarios\n\nEmpty Results\nSymptoms: result[\"table\"].instances is empty\nChecklist:\n\nCheck path matches JSON structure exactly\nVerify iteration mode is appropriate for the data type\nCheck join_keys aren’t returning None (rows with null keys are skipped)\nLook at stats for counts\n\n\n\nMissing Parent Data\nSymptoms: get_from_parent() returns None\nChecklist:\n\nVerify depth parameter matches nesting level\nEnsure parent context exists (check traversal structure)\nConfirm the parent field exists at that level\n\n\n\nDuplicate or Missing Rows\nSymptoms: Unexpected row counts\nChecklist:\n\nVerify join_keys are unique per row\nCheck for None values in join_keys (skipped)\nLook for overlapping traversals merging rows\n\n\n\nType Validation Failures\nSymptoms: Finalize errors about types\nChecklist:\n\nCheck transform outputs match model field types\nEnsure optional fields are marked Optional in model\nVerify Pydantic validators aren’t rejecting values",
    "crumbs": [
      "Developing with etielle"
    ]
  },
  {
    "objectID": "docs/developing-with-etielle.html#performance-monitoring",
    "href": "docs/developing-with-etielle.html#performance-monitoring",
    "title": "Developing with etielle",
    "section": "Performance Monitoring",
    "text": "Performance Monitoring\nAccess processing statistics:\nresult = run_mapping(data, spec)\nfor table, mapping_result in result.items():\n    print(f\"{table}:\")\n    print(f\"  Instances: {mapping_result.stats.get('num_instances', 0)}\")\n    print(f\"  Update errors: {mapping_result.stats.get('num_update_errors', 0)}\")\n    print(f\"  Finalize errors: {mapping_result.stats.get('num_finalize_errors', 0)}\")",
    "crumbs": [
      "Developing with etielle"
    ]
  },
  {
    "objectID": "docs/developing-with-etielle.html#see-also",
    "href": "docs/developing-with-etielle.html#see-also",
    "title": "Developing with etielle",
    "section": "See also",
    "text": "See also\n\nTransforms - Writing and debugging transforms\nEmissions - Understanding update vs finalize errors",
    "crumbs": [
      "Developing with etielle"
    ]
  }
]