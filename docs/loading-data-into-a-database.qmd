---
title: "Database Upserts: Loading Data"
---

**What you'll learn**: How to efficiently persist mapped data to SQLAlchemy or SQLModel databases with one-shot flushing and relationship binding.

**ETL context**: This is the **Load** step—persisting your transformed in-memory objects to a database.

## Overview

etielle's database adapters build on the relationship system to provide:

- **One-shot flushing**: Insert all rows in minimal database operations
- **Relationship binding**: Link parent-child records before persistence
- **ORM integration**: Works with SQLAlchemy and SQLModel

## Installation

Install the optional extra for your ORM:

::: {.panel-tabset}

## SQLAlchemy

```bash
uv add "etielle[sqlalchemy]"
# or
pip install "etielle[sqlalchemy]"
```

## SQLModel

```bash
uv add "etielle[sqlmodel]"
# or
pip install "etielle[sqlmodel]"
```

:::

## Why One-Shot Flushing?

**Traditional ORM approach** (multiple round trips):

1. Insert parent record → wait for database to assign ID
2. Query to get the ID back
3. Insert child record with foreign key
4. Repeat for each parent-child pair
5. Result: N+1 queries (or worse)

**etielle one-shot approach** (single flush):

1. Create all parent instances in memory
2. Create all child instances in memory
3. Link children to parents using Python object references
4. Call `session.flush()` once → ORM inserts everything
5. Result: 1-2 database operations

For 1000 users with 10 posts each, this is typically **10-100x faster**.

## Quick Start

::: {.panel-tabset}

## SQLAlchemy

``` {python}
from sqlalchemy import String, ForeignKey, create_engine
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, Session
from etielle.core import MappingSpec, TraversalSpec
from etielle.transforms import get
from etielle.instances import InstanceEmit, FieldSpec, ConstructorBuilder
from etielle.relationships import ManyToOneSpec
from etielle.adapters.sqlalchemy_adapter import bind_and_flush

# Define models
class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = "users"
    id: Mapped[str] = mapped_column(String, primary_key=True)
    name: Mapped[str] = mapped_column(String)
    posts: Mapped[list["Post"]] = relationship(back_populates="user")

class Post(Base):
    __tablename__ = "posts"
    id: Mapped[str] = mapped_column(String, primary_key=True)
    title: Mapped[str] = mapped_column(String)
    user_id: Mapped[str | None] = mapped_column(String, ForeignKey("users.id"), nullable=True)
    user: Mapped[User | None] = relationship(back_populates="posts")

# Setup database
engine = create_engine("sqlite+pysqlite:///:memory:")
Base.metadata.create_all(engine)
session = Session(engine)

# JSON data
data = {
    "users": [
        {"id": "u1", "name": "Alice"},
        {"id": "u2", "name": "Bob"},
    ],
    "posts": [
        {"id": "p1", "title": "Hello", "user_id": "u1"},
        {"id": "p2", "title": "World", "user_id": "u2"},
    ],
}

# Define emissions using ConstructorBuilder for ORM objects
users_emit = InstanceEmit[User](
    table="users",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector="id", transform=get("id")),
        FieldSpec(selector="name", transform=get("name")),
    ],
    builder=ConstructorBuilder(User),
)

posts_emit = InstanceEmit[Post](
    table="posts",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector="id", transform=get("id")),
        FieldSpec(selector="title", transform=get("title")),
    ],
    builder=ConstructorBuilder(Post),
)

# Define mapping
mapping = MappingSpec(
    traversals=[
        TraversalSpec(path=["users"], mode="auto", emits=[users_emit]),
        TraversalSpec(path=["posts"], mode="auto", emits=[posts_emit]),
    ]
)

# Define relationships
relationships = [
    ManyToOneSpec(
        child_table="posts",
        parent_table="users",
        attr="user",  # The relationship attribute on Post
        child_to_parent_key=[get("user_id")],  # How to find the parent
        required=True,
    )
]

# One-shot bind and flush
results = bind_and_flush(
    session,
    root=data,
    mapping=mapping,
    relationships=relationships,
    add_all_instances=True,
)

print(f"Users: {len(results['users'].instances)}, Posts: {len(results['posts'].instances)}")
```

## SQLModel

``` {python}
from sqlmodel import SQLModel, Field, Relationship, Session, create_engine, select
from etielle.core import MappingSpec, TraversalSpec
from etielle.transforms import get
from etielle.instances import InstanceEmit, FieldSpec, ConstructorBuilder
from etielle.relationships import ManyToOneSpec
from etielle.adapters.sqlmodel_adapter import bind_and_flush

# Define models
class User(SQLModel, table=True):
    __tablename__ = "sm_users"
    id: str = Field(primary_key=True)
    name: str
    posts: list["Post"] = Relationship(back_populates="user")

class Post(SQLModel, table=True):
    __tablename__ = "sm_posts"
    id: str = Field(primary_key=True)
    title: str
    user_id: str | None = Field(default=None, foreign_key="sm_users.id")
    user: User | None = Relationship(back_populates="posts")

# Setup database
engine = create_engine("sqlite+pysqlite:///:memory:")
SQLModel.metadata.create_all(engine)
session = Session(engine)

# JSON data
data = {
    "users": [
        {"id": "u1", "name": "Alice"},
        {"id": "u2", "name": "Bob"},
    ],
    "posts": [
        {"id": "p1", "title": "Hello", "user_id": "u1"},
        {"id": "p2", "title": "World", "user_id": "u2"},
    ],
}

# Same pattern as SQLAlchemy
users_emit = InstanceEmit[User](
    table="users",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector="id", transform=get("id")),
        FieldSpec(selector="name", transform=get("name")),
    ],
    builder=ConstructorBuilder(User),
)

posts_emit = InstanceEmit[Post](
    table="posts",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector="id", transform=get("id")),
        FieldSpec(selector="title", transform=get("title")),
    ],
    builder=ConstructorBuilder(Post),
)

mapping = MappingSpec(
    traversals=[
        TraversalSpec(path=["users"], mode="auto", emits=[users_emit]),
        TraversalSpec(path=["posts"], mode="auto", emits=[posts_emit]),
    ]
)

relationships = [
    ManyToOneSpec(
        child_table="posts",
        parent_table="users",
        attr="user",
        child_to_parent_key=[get("user_id")],
        required=True,
    )
]

results = bind_and_flush(
    session,
    root=data,
    mapping=mapping,
    relationships=relationships,
    add_all_instances=True,
)

print(f"Users: {len(results['users'].instances)}, Posts: {len(results['posts'].instances)}")
```

:::

## ConstructorBuilder for ORM Objects

When working with ORM models, use `ConstructorBuilder` instead of `PydanticBuilder`:

```python
from etielle.instances import ConstructorBuilder

# ConstructorBuilder calls User(**fields) to create instances
builder = ConstructorBuilder(User)
```

This works because SQLAlchemy and SQLModel models accept keyword arguments in their constructors.

**When to use each builder:**

| Builder | Use case |
|---------|----------|
| `PydanticBuilder` | Pure Pydantic models (not ORM) |
| `ConstructorBuilder` | SQLAlchemy/SQLModel ORM models |
| `TypedDictBuilder` | Plain dictionaries |

## Relationship Binding

Relationships are defined with `ManyToOneSpec`:

```python
from etielle.relationships import ManyToOneSpec
from etielle.transforms import get

ManyToOneSpec(
    child_table="posts",      # Table with the foreign key
    parent_table="users",     # Table being referenced
    attr="user",              # Relationship attribute on child model
    child_to_parent_key=[     # Transform(s) to find the parent's join_key
        get("user_id")
    ],
    required=True,            # Error if parent not found
)
```

### How it Works

1. **Compute keys**: etielle traverses the JSON again to compute which child belongs to which parent
2. **Store in sidecar**: Relationships are stored separately from instances
3. **Bind in memory**: Child objects are linked to parent objects via Python references
4. **Flush once**: SQLAlchemy/SQLModel handles foreign keys automatically

### Nested Data Example

When parent-child data is nested in the JSON:

```python
data = {
    "users": [
        {"id": "u1", "name": "Alice", "posts": [
            {"id": "p1", "title": "Hello"},
            {"id": "p2", "title": "World"}
        ]}
    ]
}

# Use get_from_parent to reference the parent's ID
relationships = [
    ManyToOneSpec(
        child_table="posts",
        parent_table="users",
        attr="user",
        child_to_parent_key=[get_from_parent("id")],  # Get ID from parent context
    )
]
```

## Before-Flush Hook

For fine-grained control over transactions, use `install_before_flush_binder`:

::: {.panel-tabset}

## SQLAlchemy

```python
from etielle.adapters.sqlalchemy_adapter import install_before_flush_binder

install_before_flush_binder(
    session,
    root=data,
    mapping=mapping,
    relationships=relationships,
)

# Do other session work...
# Binding happens automatically when you flush
session.flush()
```

## SQLModel

```python
from etielle.adapters.sqlmodel_adapter import install_before_flush_binder

install_before_flush_binder(
    session,
    root=data,
    mapping=mapping,
    relationships=relationships,
)

session.flush()
```

:::

## API Reference

### bind_and_flush

```python
def bind_and_flush(
    session: Session,
    root: Any,                      # The JSON data
    mapping: MappingSpec,           # Your mapping specification
    relationships: list[ManyToOneSpec],  # Relationship definitions
    add_all_instances: bool = True,  # Add instances to session
) -> dict[str, MappingResult]:
```

### install_before_flush_binder

```python
def install_before_flush_binder(
    session: Session,
    root: Any,
    mapping: MappingSpec,
    relationships: list[ManyToOneSpec],
) -> None:
```

### ManyToOneSpec

| Parameter | Type | Description |
|-----------|------|-------------|
| `child_table` | `str` | Name of the child table (has foreign key) |
| `parent_table` | `str` | Name of the parent table (referenced) |
| `attr` | `str` | Relationship attribute name on child model |
| `child_to_parent_key` | `list[Transform]` | Transforms to compute parent's join_key |
| `required` | `bool` | If `True`, missing parent is an error |

## Performance Notes

- Autoflush is temporarily disabled during one-shot operations
- Instances are added and flushed once; ORMs populate FKs via relationships
- For very large datasets, consider batching (chunking the JSON input)

## See also

- [Relationships](relationships.qmd) - In-memory relationship binding without database
- [Emissions](emissions.qmd) - Creating the instances that get loaded
