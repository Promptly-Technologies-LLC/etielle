---
title: "Emissions: Building Output Tables"
---

**What you'll learn**: How to emit data to dictionaries, Pydantic models, TypedDicts, or ORM objects, with merge logic for progressive construction.

**ETL context**: Emissions are table-level transformationâ€”the second part of the **Transform** step. They define the structure of your output tables.

## What is an Emission?

An emission defines what table rows to create at each position in a traversal. There are two types:

- **`TableEmit`**: Produces plain dictionaries (simple, quick to set up)
- **`InstanceEmit`**: Produces typed instances (Pydantic models, TypedDicts, ORM objects)

## TableEmit: Quick and Simple

Use `TableEmit` for prototyping or when you just need dictionaries:

``` {python}
from etielle.core import MappingSpec, TraversalSpec, TableEmit, Field
from etielle.transforms import get
from etielle.executor import run_mapping
import json

data = {"users": [{"id": "u1", "email": "alice@example.com"}]}

spec = MappingSpec(traversals=[
    TraversalSpec(
        path=["users"],
        mode="auto",
        emits=[TableEmit(
            table="users",
            join_keys=[get("id")],
            fields=[
                Field("id", get("id")),
                Field("email", get("email"))
            ]
        )]
    )
])

result = run_mapping(data, spec)
print(json.dumps(list(result["users"].instances.values()), indent=2))
```

### TableEmit Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `table` | `str` | Name of the output table |
| `join_keys` | `list[Transform]` | Transforms that produce the unique row identifier |
| `fields` | `list[Field]` | List of `Field(name, transform)` for each column |

## InstanceEmit: Typed Output

Use `InstanceEmit` when you want:

- **Validation**: Pydantic validates as it builds
- **Type safety**: Your IDE knows the exact type
- **ORM integration**: Create database objects directly

``` {python}
from etielle.core import MappingSpec, TraversalSpec, field_of
from etielle.transforms import get
from etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder
from etielle.executor import run_mapping
from pydantic import BaseModel

class User(BaseModel):
    id: str
    email: str

data = {"users": [{"id": "u1", "email": "alice@example.com"}]}

spec = MappingSpec(traversals=[
    TraversalSpec(
        path=["users"],
        mode="auto",
        emits=[InstanceEmit[User](
            table="users",
            join_keys=[get("id")],
            builder=PydanticBuilder(User),
            fields=[
                FieldSpec(selector=field_of(User, lambda u: u.id), transform=get("id")),
                FieldSpec(selector=field_of(User, lambda u: u.email), transform=get("email")),
            ]
        )]
    )
])

result = run_mapping(data, spec)
user = list(result["users"].instances.values())[0]
print(f"Type: {type(user).__name__}, email: {user.email}")
```

## Builders

Builders control how instances are constructed:

### PydanticBuilder

For Pydantic models with full validation:

```python
from etielle.instances import PydanticBuilder
from pydantic import BaseModel

class User(BaseModel):
    id: str
    email: str

builder = PydanticBuilder(User)
```

### PydanticPartialBuilder

For Pydantic models where some fields might be missing:

```python
from etielle.instances import PydanticPartialBuilder

builder = PydanticPartialBuilder(User)  # Creates partial models
```

### TypedDictBuilder

For plain dicts or when you don't want Pydantic:

```python
from typing import TypedDict
from etielle.instances import TypedDictBuilder

class UserTD(TypedDict):
    id: str
    email: str

builder = TypedDictBuilder(lambda d: UserTD(**d))
```

### ConstructorBuilder

For ORM objects (SQLAlchemy, SQLModel) or any class that accepts keyword arguments:

```python
from etielle.instances import ConstructorBuilder

# Works with SQLAlchemy/SQLModel models
builder = ConstructorBuilder(User)  # User(**fields)
```

## Progressive Construction

Multiple traversals can contribute to the same instance. Rows with matching `join_keys` are merged:

``` {python}
from etielle.core import MappingSpec, TraversalSpec, TableEmit, Field
from etielle.transforms import get
from etielle.executor import run_mapping

data = {
    "users": [{"id": "u1", "name": "Alice"}],
    "profiles": [{"user_id": "u1", "email": "alice@example.com", "bio": "Developer"}]
}

spec = MappingSpec(traversals=[
    # Traversal 1: Basic user info
    TraversalSpec(
        path=["users"],
        mode="auto",
        emits=[TableEmit(
            table="users",
            join_keys=[get("id")],
            fields=[
                Field("id", get("id")),
                Field("name", get("name"))
            ]
        )]
    ),
    # Traversal 2: Add profile info to the same user
    TraversalSpec(
        path=["profiles"],
        mode="auto",
        emits=[TableEmit(
            table="users",  # Same table!
            join_keys=[get("user_id")],  # Matches "u1"
            fields=[
                Field("email", get("email")),
                Field("bio", get("bio"))
            ]
        )]
    )
])

result = run_mapping(data, spec)
user = list(result["users"].instances.values())[0]
print(user)  # Has id, name, email, and bio
```

## Merge Policies

By default, if two traversals update the same field, the last write wins. Merge policies change this behavior:

| Policy | Behavior | Use case |
|--------|----------|----------|
| `AddPolicy()` | Adds numbers together | Counters, sums, totals |
| `AppendPolicy()` | Appends single items to list | Collecting tags/flags |
| `ExtendPolicy()` | Extends list with another list | Merging lists |
| `MinPolicy()` | Keeps minimum value | Earliest date, lowest score |
| `MaxPolicy()` | Keeps maximum value | Latest date, highest score |
| `FirstNonNullPolicy()` | Keeps first non-null value | Fallback defaults |

### Example: Counting with AddPolicy

``` {python}
from etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder, AddPolicy
from etielle.transforms import get, literal
from etielle.core import MappingSpec, TraversalSpec
from etielle.executor import run_mapping
from pydantic import BaseModel

class User(BaseModel):
    id: str
    login_count: int = 0

emit = InstanceEmit[User](
    table="users",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector="id", transform=get("id")),
        FieldSpec(selector="login_count", transform=literal(1)),
    ],
    builder=PydanticBuilder(User),
    policies={"login_count": AddPolicy()},  # Sum instead of overwrite
)

root = {"users": [{"id": "u1"}]}
mapping = MappingSpec(traversals=[
    TraversalSpec(path=["users"], mode="auto", emits=[emit]),
    TraversalSpec(path=["users"], mode="auto", emits=[emit]),  # Same emit twice!
])

result = run_mapping(root, mapping)
user = list(result["users"].instances.values())[0]
print(f"login_count: {user.login_count}")  # 2 (1 + 1)
```

### Example: Collecting Tags with AppendPolicy

``` {python}
from etielle.instances import InstanceEmit, FieldSpec, PydanticBuilder, AppendPolicy
from etielle.transforms import get, literal
from etielle.core import MappingSpec, TraversalSpec, field_of
from etielle.executor import run_mapping
from pydantic import BaseModel

class User(BaseModel):
    id: str
    tags: list[str] = []

emit1 = InstanceEmit[User](
    table="users",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector=field_of(User, lambda u: u.id), transform=get("id")),
        FieldSpec(selector=field_of(User, lambda u: u.tags), transform=literal("verified")),
    ],
    builder=PydanticBuilder(User),
    policies={"tags": AppendPolicy()},
)

emit2 = InstanceEmit[User](
    table="users",
    join_keys=[get("id")],
    fields=[
        FieldSpec(selector=field_of(User, lambda u: u.tags), transform=literal("premium")),
    ],
    builder=PydanticBuilder(User),
    policies={"tags": AppendPolicy()},
)

root = {"users": [{"id": "u1"}]}
mapping = MappingSpec(traversals=[
    TraversalSpec(path=["users"], mode="auto", emits=[emit1]),
    TraversalSpec(path=["users"], mode="auto", emits=[emit2]),
])

result = run_mapping(root, mapping)
user = list(result["users"].instances.values())[0]
print(f"tags: {user.tags}")  # ["verified", "premium"]
```

## Type-Safe Field Selectors

Use `field_of()` for type-checked field references:

```python
from etielle.core import field_of

class User:
    id: str
    email: str

# Type-safe: IDE autocomplete, typos caught at type-check time
field_of(User, lambda u: u.email)  # Returns "email"

# Typo would be caught by type checker:
# field_of(User, lambda u: u.emial)  # Error!
```

When to use field selectors vs strings:

| Use `field_of()` when... | Use strings when... |
|--------------------------|---------------------|
| Working with typed models | Working with plain dicts |
| Using a type checker | Prototyping quickly |
| Want IDE autocomplete | Field names are dynamic |

## InstanceEmit Reference

| Parameter | Type | Description |
|-----------|------|-------------|
| `table` | `str` | Name of the output table |
| `join_keys` | `list[Transform]` | Unique row identifier |
| `fields` | `list[FieldSpec]` | Field specifications |
| `builder` | `InstanceBuilder` | How to construct instances |
| `policies` | `dict[str, MergePolicy]` | Optional merge policies by field name |
| `strict_fields` | `bool` | Validate field names (default: `True`) |
| `strict_mode` | `str` | `"collect"` (default) or `"fail_fast"` |

## See also

- [Transforms](transforms.qmd) - The transforms used in Field and FieldSpec
- [Developing with etielle](developing-with-etielle.qmd) - Error reporting and debugging
- [Relationships](relationships.qmd) - Linking emitted instances together
- [Database upserts](loading-data-into-a-database.qmd) - Persisting instances to a database
